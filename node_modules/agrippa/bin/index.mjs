#!/usr/bin/env node
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import EventEmitter from 'events';
import { formatWithOptions, promisify } from 'util';
import chalk from 'chalk';
import path, { extname, resolve, basename, dirname, join } from 'path';
import { entries, pipe, filter, map, tuple, toObject, pick, reduce } from 'rhax';
import { readFile, mkdir, writeFile } from 'fs/promises';
import { cwd } from 'process';
import { pathToFileURL, fileURLToPath } from 'url';
import JSON5 from 'json5';
import findUp from 'find-up';
import axios from 'axios';
import semver from 'semver';
import { existsSync, readFileSync } from 'fs';
import { exec as exec$1 } from 'child_process';

var Framework = /* @__PURE__ */ ((Framework2) => {
  Framework2["REACT"] = "react";
  Framework2["SOLIDJS"] = "solidjs";
  Framework2["PREACT"] = "preact";
  Framework2["REACT_NATIVE"] = "react-native";
  return Framework2;
})(Framework || {});
((Framework2) => {
  const values = [
    "react" /* REACT */,
    "solidjs" /* SOLIDJS */,
    "preact" /* PREACT */,
    "react-native" /* REACT_NATIVE */
  ];
  function fromString(str) {
    return values.find((fw) => fw === str) ?? null;
  }
  Framework2.fromString = fromString;
})(Framework || (Framework = {}));

var Styling = /* @__PURE__ */ ((Styling2) => {
  Styling2["CSS"] = "css";
  Styling2["SCSS"] = "scss";
  Styling2["JSS"] = "jss";
  Styling2["STYLED_COMPONENTS"] = "styled-components";
  Styling2["REACT_NATIVE"] = "react-native";
  return Styling2;
})(Styling || {});
((Styling2) => {
  const values = [
    "css" /* CSS */,
    "scss" /* SCSS */,
    "jss" /* JSS */,
    "styled-components" /* STYLED_COMPONENTS */,
    "react-native" /* REACT_NATIVE */
  ];
  function fromString(str) {
    return values.find((sty) => sty === str) ?? null;
  }
  Styling2.fromString = fromString;
})(Styling || (Styling = {}));

const styles = {
  componentName: chalk.hex("#FCD558").bold,
  tag: chalk.hex("#00D8FF").bold,
  error: chalk.red,
  warning: chalk.hex("#FFD307"),
  debug: chalk.cyan,
  success: chalk.green,
  comment: chalk.gray,
  path: chalk.gray.italic,
  bold: chalk.bold,
  italic: chalk.italic,
  NA: chalk.hex("#B6B6B6"),
  command: chalk.magenta
};
const { bold, italic } = styles;

class Logger extends EventEmitter {
  constructor(isDebug = false) {
    super();
    this.logs = [];
    this.isDebug = isDebug;
    this.on("error", () => {
    });
  }
  static consoleLogger(isDebug = false) {
    const logger = new Logger(isDebug);
    logger.on("log", ({ type, message }) => void (type === "error" ? console.error : console.log)(message));
    return logger;
  }
  static create(isPure, isDebug) {
    return isPure ? new Logger(isDebug) : Logger.consoleLogger(isDebug);
  }
  format(args, style = (x) => x) {
    return args.map((msg) => formatWithOptions({ colors: true }, msg)).map((msg) => style(msg)).join("\n");
  }
  log(type, message) {
    const logObject = { type, message };
    this.logs.push(logObject);
    this.emit("log", logObject);
    this.emit(type, message);
  }
  debug(...data) {
    if (this.isDebug) {
      const message = this.format(data, styles.debug);
      this.log("debug", message);
    }
  }
  info(...data) {
    const message = this.format(data);
    this.log("info", message);
  }
  warn(...data) {
    const message = this.format(data, styles.warning);
    this.log("warning", message);
  }
  error(...data) {
    const message = this.format(data, styles.error);
    this.log("error", message);
  }
  consume() {
    const logs = this.logs;
    this.logs = [];
    return logs.map((l) => l.message).join("\n");
  }
}

const cstr = (condition, string) => {
  return condition ? string : "";
};
const indent = (str, num = 1, token = "	") => {
  return str.split("\n").map((line) => token.repeat(num) + line).join("\n");
};
const joinLines = (...lines) => lines.filter((line) => typeof line === "string").join("\n");
const isLowerCase = (str) => str === str.toLocaleLowerCase();
const capitalize = (str) => str && str[0].toLocaleUpperCase() + str.slice(1);
const isKebabCase = (str) => str.split("-").every(isLowerCase);
const isCamelCase = (str) => !str || /^[a-z][A-Za-z\d]*$/.test(str);
const isPascalCase = (str) => !str || /^[A-Z][A-Za-z\d]*$/.test(str);
const pascalCase = (str) => {
  if (isPascalCase(str)) {
    return str;
  } else if (isCamelCase(str)) {
    return capitalize(str);
  } else if (isKebabCase(str)) {
    return str.split("-").map(capitalize).join("");
  }
  throw RangeError("Improper string formatting");
};
const kebabCase = (str) => {
  if (isPascalCase(str) || isCamelCase(str)) {
    return str.split(/(?=[A-Z])/).map((segment) => segment.toLocaleLowerCase()).join("-");
  } else if (isKebabCase(str)) {
    return str;
  }
  throw RangeError("Improper string formatting");
};

function assignDefaults(o1, o2) {
  for (const [key, value] of entries(o2)) {
    if (value === void 0) {
      continue;
    } else if (typeof value === "object" && value !== null) {
      if (typeof o1[key] !== "object" || o1[key] === null) {
        o1[key] = {};
      }
      assignDefaults(o1[key], value);
    } else {
      o1[key] = value;
    }
  }
  return o1;
}

const defaultFramework = (packageJson) => {
  const dependencies = packageJson?.dependencies ?? {};
  if ("react-native" in dependencies) {
    return Framework.REACT_NATIVE;
  } else if ("preact" in dependencies) {
    return Framework.PREACT;
  } else if ("solid-js" in dependencies) {
    return Framework.SOLIDJS;
  } else if ("react" in dependencies) {
    return Framework.REACT;
  }
  return "";
};
function createOptions(input, envFiles) {
  const { packageJson, tsconfig } = envFiles;
  const { styling } = input;
  const name = pascalCase(input.name);
  input.name = name;
  const framework = input.framework ?? defaultFramework(packageJson);
  const createStylesFile = [Styling.CSS, Styling.SCSS, Styling.STYLED_COMPONENTS].includes(styling);
  const defaults = {
    name,
    componentOptions: {
      exportType: "named",
      declaration: "const"
    },
    framework,
    reactOptions: framework === Framework.REACT || framework === Framework.REACT_NATIVE ? {
      importReact: false
    } : void 0,
    solidjsOptions: framework === Framework.SOLIDJS ? {} : void 0,
    preactOptions: framework === Framework.PREACT ? {} : void 0,
    reactNativeOptions: framework === Framework.REACT_NATIVE ? {} : void 0,
    typescript: !!tsconfig,
    typescriptOptions: !!tsconfig || input.typescript ? {
      propDeclaration: "interface"
    } : void 0,
    styling,
    createStylesFile,
    styleFileOptions: createStylesFile ? {
      module: true
    } : void 0,
    baseDir: process.cwd(),
    destination: ".",
    allowOutsideBase: false,
    overwrite: false,
    pure: false,
    reportTelemetry: true,
    lookForUpdates: true,
    debug: false
  };
  return assignDefaults(defaults, input);
}

const parseJson$1 = JSON5.parse;
var FileType = /* @__PURE__ */ ((FileType2) => {
  FileType2["JSON"] = "json";
  FileType2["JS"] = "js";
  FileType2["MJS"] = "mjs";
  return FileType2;
})(FileType || {});
((FileType2) => {
  FileType2.values = ["json" /* JSON */, "js" /* JS */, "mjs" /* MJS */];
  function fromString(str) {
    return FileType2.values.find((type) => type === str) ?? null;
  }
  FileType2.fromString = fromString;
})(FileType || (FileType = {}));
async function loadFile(path, type) {
  const extension = extname(path).slice(1);
  if (type && !FileType.fromString(type)) {
    throw new Error(`Unsupported file type: ${type}. loadFiles supports only the following file types: ${FileType.values.join(", ")}`);
  }
  const fileType = type ?? FileType.fromString(extension);
  if (!fileType) {
    throw new Error(`A type was not passed, and could not be determined from the file path (${path})`);
  }
  const resolvedPath = resolve(cwd(), path);
  switch (fileType) {
    case "json" /* JSON */:
      return parseJson$1(await readFile(resolvedPath, "utf8"));
    case "js" /* JS */:
      return (await import(pathToFileURL(resolvedPath).toString())).default;
    case "mjs" /* MJS */:
      return (await import(pathToFileURL(resolvedPath).toString())).default;
  }
}
async function loadFileQuery(query, type) {
  const path = "path" in query ? query.path : await findUp(query.search);
  if (!path) {
    return [null, null];
  }
  return [await loadFile(path, type), path];
}

const defaultFileQueries = {
  packageJson: { search: "package.json" },
  tsconfig: { search: "tsconfig.json" }
};
async function loadFiles(customFileQueries = {}, basePath = ".") {
  const fileQueries = pipe({ ...defaultFileQueries, ...customFileQueries })(entries)(filter(([, f]) => !!f))(map(([k, val]) => tuple(k, typeof val === "string" ? { path: val } : val)))(map(([k, val]) => tuple(k, "path" in val ? { path: resolve(basePath, val.path) } : val)))(toObject).go();
  const filePromises = pipe(fileQueries)(entries)(map(([name, query]) => loadFileQuery(query).then(([f]) => tuple(name, f)))).go();
  const files = toObject(await Promise.all(filePromises));
  return files;
}

class Plugin {
  constructor() {
  }
  _initialize(context) {
    this.context = context;
    this.onContext?.();
    this.onCreateStackTags && context.addListener("create-stack-tags", this.onCreateStackTags.bind(this));
    this.onCreateStages && context.addListener("create-stages", this.onCreateStages.bind(this));
    this.onStageStart && context.addListener("stage-start", this.onStageStart.bind(this));
    this.onStageEnd && context.addListener("stage-end", this.onStageEnd.bind(this));
    this.onPipelineStart && context.addListener("pipeline-start", this.onPipelineStart.bind(this));
    this.onPipelineEnd && context.addListener("pipeline-end", this.onPipelineEnd.bind(this));
  }
}

const { diff, gt, lt } = semver;
const AGRIPPA_NPM_ENDPOINT = "https://registry.npmjs.org/agrippa/latest";
class UpdatesPlugin extends Plugin {
  constructor() {
    super(...arguments);
    this.currentVersion = void 0;
    this.requestPromise = null;
    this.failed = false;
  }
  async pingRegistry() {
    const { logger } = this.context;
    logger.debug("UpdatesPlugin: pinging the npm registry");
    const sendTime = Date.now();
    try {
      const res = await axios.get(AGRIPPA_NPM_ENDPOINT, {
        timeout: 5e3
      });
      const endTime = Date.now();
      logger.debug(`UpdatesPlugin: request resolved with status ${res.status}, took ${endTime - sendTime}ms`);
      const latestVersion = res.data.version;
      return latestVersion;
    } catch (e) {
      logger.debug(`UpdatesPlugin - ${e.code === "ECONNABORTED" ? "pinging the NPM registry timed out." : "pinging the NPM registry failed."}`);
      this.failed = true;
      logger.debug(e);
      return;
    }
  }
  onPipelineStart() {
    this.currentVersion = this.context.version;
    this.requestPromise = this.pingRegistry();
  }
  async onPipelineEnd() {
    const { logger } = this.context;
    const currentVersion = this.currentVersion;
    const latestVersion = await this.requestPromise;
    if (this.failed) {
      return;
    }
    logger.debug(`Current version: ${italic(currentVersion)}, Latest version: ${italic(latestVersion)}`);
    if (!currentVersion || !latestVersion) {
      logger.warn("Error in UpdatesPlugin: currentVersion or latestVersion are not set.");
      return;
    }
    if (gt(latestVersion, currentVersion)) {
      const df = diff(latestVersion, currentVersion);
      logger.info(bold(`New ${df} version available: ${latestVersion}!`), bold(`please update now by typing ${styles.command("npm i -g agrippa")} into the terminal`));
    } else if (lt(latestVersion, currentVersion)) {
      logger.debug("Current version is greater than the latest stable release");
    }
  }
}

const TELEMETRY_ENDPOINT = "https://agrippa-report-worker.nitzanhen.workers.dev/";
class TelemetryPlugin extends Plugin {
  async onPipelineEnd() {
    const { options, logger, version } = this.context;
    const runData = {
      ...pick(options, "framework", "typescript", "styling"),
      version
    };
    const sendTime = Date.now();
    try {
      logger.debug("TelemetryPlugin: sending report...");
      await axios.post(TELEMETRY_ENDPOINT, runData, {
        timeout: options.debug ? 0 : 1
      }).catch((e) => {
        if (!options.debug && e.code === "ECONNABORTED") {
          return;
        }
        throw e;
      });
      const endTime = Date.now();
      logger.debug(`TelemetryPlugin: received response in ${endTime - sendTime}ms.`);
    } catch (e) {
      const endTime = Date.now();
      logger.debug(`TelemetryPlugin: request failed after ${endTime - sendTime}ms. Error:`);
      logger.debug(e);
    }
  }
}

class Stage {
  constructor() {
    this.silent = false;
  }
}

function isSubDirectory(parent, dir) {
  if (parent === dir) {
    return true;
  }
  const relativePath = path.relative(parent, dir);
  return !!relativePath && !relativePath.startsWith("..") && !path.isAbsolute(relativePath);
}

class StageResult {
  constructor(status, summary) {
    this.status = status;
    this.summary = summary;
  }
}
const stageStatusBullets = {
  success: "\u2713",
  warning: "\u2713",
  error: "\u2717",
  NA: "\u2022"
};
var StageStatus = /* @__PURE__ */ ((StageStatus2) => {
  StageStatus2["SUCCESS"] = "success";
  StageStatus2["WARNING"] = "warning";
  StageStatus2["ERROR"] = "error";
  StageStatus2["NA"] = "NA";
  return StageStatus2;
})(StageStatus || {});
const summaryLine = ({ status, summary }) => styles[status].bold(`${stageStatusBullets[status]} ${summary}`);

class CreateDirStage extends Stage {
  constructor({
    dir,
    recursive = true,
    varKey
  }) {
    super();
    this.dir = dir;
    this.recursive = recursive;
    this.varKey = varKey;
  }
  updateContext(context) {
    context.addDir(this.dir);
    if (this.varKey) {
      context.addVariable(this.varKey, this.dir.path);
    }
  }
  async execute(context, logger) {
    const { options } = context;
    const { pure, baseDir, allowOutsideBase, overwrite } = options;
    const { path } = this.dir;
    const dirName = basename(path);
    if (pure) {
      this.updateContext(context);
      return new StageResult(StageStatus.NA, "No directory created (pure mode)");
    }
    if (baseDir && !isSubDirectory(baseDir, path) && !allowOutsideBase) {
      logger.error(joinLines(`The resolved path for the directory ${italic(dirName)} falls outside the base directory.`, `Base directory: ${italic(baseDir)}`, `Resolved directory: ${italic(path)}`, "To allow this behaviour, pass the '--allow-outside-base' flag or set 'allowOutsideBase: true' in agrippa.config.mjs"));
      return new StageResult(StageStatus.ERROR, "Directory path outside baseDir");
    }
    logger.info(`path: ${styles.path(path)}`);
    if (existsSync(path) && !overwrite) {
      logger.info(`To allow overwriting, pass ${bold("--overwrite")} to the command.`);
      return new StageResult(StageStatus.ERROR, `Directory ${italic(dirName)} already exists.`);
    }
    try {
      await mkdir(path, { recursive: this.recursive });
      this.updateContext(context);
      return new StageResult(StageStatus.SUCCESS, `Directory ${italic(dirName)} created successfully.`);
    } catch (e) {
      logger.error(e);
      return new StageResult(StageStatus.ERROR, `Creation of directory ${dirName} failed.`);
    }
  }
}

class CreateFileStage extends Stage {
  constructor({
    file,
    varKey
  }) {
    super();
    this.file = file;
    this.varKey = varKey;
  }
  updateContext(context) {
    context.addFile(this.file);
    if (this.varKey) {
      context.addVariable(this.varKey, this.file.path);
    }
  }
  async execute(context, logger) {
    const { options } = context;
    const { pure, baseDir, allowOutsideBase, overwrite } = options;
    const { data, path } = this.file;
    if (pure) {
      this.updateContext(context);
      return new StageResult(StageStatus.NA, "No file created (pure mode)");
    }
    const filename = basename(path);
    if (baseDir && !isSubDirectory(baseDir, path) && !allowOutsideBase) {
      logger.error(joinLines(`The resolved path for the directory ${italic(filename)} falls outside the base directory.`, `Base directory: ${italic(baseDir)}`, `Resolved directory: ${italic(path)}`, "To allow this behaviour, pass the '--allow-outside-base' flag or set 'allowOutsideBase: true' in agrippa.config.mjs"));
      return new StageResult(StageStatus.ERROR, "Directory path outside baseDir");
    }
    logger.info(`path: ${styles.path(path)}`);
    if (existsSync(path)) {
      if (!overwrite) {
        logger.info(`To allow overwriting, pass ${bold("--overwrite")} to the command.`);
        return new StageResult(StageStatus.ERROR, `File ${italic(filename)} already exists.`);
      }
      logger.info("File exists, and was overwritten.");
    }
    try {
      await writeFile(path, data);
      this.updateContext(context);
      return new StageResult(StageStatus.SUCCESS, `File ${italic(filename)} created successfully.`);
    } catch (e) {
      logger.error(e);
      return new StageResult(StageStatus.ERROR, `Creation of file ${filename} failed.`);
    }
  }
}

class AgrippaFile {
  constructor(path, data) {
    this.path = path;
    this.data = data;
  }
  get directory() {
    return dirname(this.path);
  }
  get extension() {
    return extname(this.path);
  }
  get fileName() {
    return basename(this.path, this.extension);
  }
  toJSON() {
    return JSON.stringify({
      path: this.path,
      data: this.data,
      directory: this.directory,
      extension: this.extension,
      fileName: this.fileName
    });
  }
}

class AgrippaDir {
  constructor(path) {
    this.path = path;
  }
}

class CreateDirPlugin extends Plugin {
  constructor({
    dir,
    recursive,
    varKey
  }) {
    super();
    this.dir = dir;
    this.recursive = recursive;
    this.varKey = varKey;
  }
  onCreateStages() {
    this.context.addStage(new CreateDirStage({
      dir: this.dir,
      recursive: this.recursive,
      varKey: this.varKey
    }));
  }
}

class CreateFilePlugin extends Plugin {
  constructor({
    file,
    varKey
  }) {
    super();
    this.file = file;
    this.varKey = varKey;
  }
  onCreateStages() {
    this.context.addStage(new CreateFileStage({
      file: this.file,
      varKey: this.varKey
    }));
  }
}

const exec = promisify(exec$1);
class RunCommandStage extends Stage {
  constructor({
    rawCommand
  }) {
    super();
    this.rawCommand = rawCommand;
  }
  async execute(context, logger) {
    logger.debug("runCommand: initiated");
    logger.debug(`Raw command (before substituting variables): ${this.rawCommand}`);
    const { variables } = context;
    logger.debug("Context variables:", variables);
    const command = reduce.object(variables, (cmd, value, key) => cmd.replace(`<${key}>`, value), this.rawCommand);
    logger.debug(`Command (after substituting variables): ${command}`);
    try {
      const { stdout, stderr } = await exec(command);
      if (stderr) {
        throw new Error(stderr);
      }
      logger.info(stdout ? `output: ${stdout}` : "No output received from command.");
      return new StageResult(StageStatus.SUCCESS, "Post command successfully executed");
    } catch (e) {
      logger.error(e);
      return new StageResult(StageStatus.ERROR, "Post command failed");
    }
  }
}

class PostCommandPlugin extends Plugin {
  constructor(command) {
    super();
    this.command = command;
  }
  onCreateStages() {
    this.context.addStage(new RunCommandStage({ rawCommand: this.command }));
  }
}

class StackTagPlugin extends Plugin {
  constructor(tags) {
    super();
    this.tags = tags;
  }
  onCreateStackTags() {
    for (const tag of this.tags) {
      this.context.addStackTag(tag);
    }
  }
}

class Blocks {
  constructor(initialBlocks = []) {
    this.initialBlocks = initialBlocks;
    const keyBlockPairs = initialBlocks.map((b) => tuple(b.key, b));
    this.blocks = new Map(keyBlockPairs);
  }
  get(key) {
    return this.blocks.get(key);
  }
  add({ key, precedence, data, separator = "\n\n" }) {
    this.blocks.set(key, { key, precedence, data, separator });
  }
  delete(key) {
    return this.blocks.delete(key);
  }
  join() {
    if (this.blocks.size === 0) {
      return "";
    }
    const blocksSorted = [...this.blocks.values()].sort((b1, b2) => b1.precedence - b2.precedence);
    const head = blocksSorted.slice(0, -1);
    const last = blocksSorted[blocksSorted.length - 1];
    return [
      ...head.map(({ data, separator }) => data + separator),
      last.data
    ].join("");
  }
}

var Import;
((Import2) => {
  function stringify(i) {
    const { module, namedImports, defaultImport } = i;
    const namedString = namedImports?.length ? `{ ${namedImports?.join(", ")} }` : null;
    return `import ${defaultImport ?? ""}${cstr(!!defaultImport && !!namedString, ", ")}${namedString ?? ""}${cstr(!!defaultImport || !!namedString, " from ")}'${module}';`;
  }
  Import2.stringify = stringify;
  function merge(i1, i2) {
    if (i1.module !== i2.module) {
      throw new RangeError("Illogical merge: both imports must refer to the same module");
    }
    const module = i1.module;
    const default1 = i1.defaultImport;
    const default2 = i2.defaultImport;
    const named1 = i1.namedImports ?? [];
    const named2 = i2.namedImports ?? [];
    if (default1 && default2 && default1 !== default2) {
      throw new RangeError("Illogical merge: cannot merge two different default imports.");
    }
    const defaultImport = default1 ?? default2;
    const namedImports = [...named1, ...named2];
    return {
      module,
      defaultImport,
      namedImports: namedImports.length > 0 ? namedImports : void 0
    };
  }
  Import2.merge = merge;
})(Import || (Import = {}));

const _Imports = class {
  constructor() {
    this.imports = /* @__PURE__ */ new Map();
  }
  get(module) {
    return this.imports.get(module);
  }
  delete(module) {
    return this.imports.delete(module);
  }
  add(newImport) {
    const module = newImport.module;
    const oldImport = this.imports.get(module);
    const i = oldImport ? Import.merge(oldImport, newImport) : newImport;
    this.imports.set(module, i);
  }
  get size() {
    return this.imports.size;
  }
  getBlock() {
    const data = [...this.imports.values()].map(Import.stringify).join("\n") + "\n";
    return {
      key: _Imports.BLOCK_KEY,
      precedence: _Imports.BLOCK_PRECEDENCE,
      data,
      separator: "\n"
    };
  }
};
let Imports = _Imports;
Imports.BLOCK_KEY = "imports";
Imports.BLOCK_PRECEDENCE = -Number.EPSILON;

var Comment;
((Comment2) => {
  function stringify(c) {
    switch (c.type) {
      case "single":
        return c.content.split("\n").map((ln) => `// ${ln}`).join("");
      case "block":
        return pipe(c.content)((data) => data.split("\n").map((ln) => " * " + ln).join("\n"))((body) => `/*
${body}
 */`).go();
      case "jsdoc":
        return pipe(c.content)((data) => data.split("\n").map((ln) => " * " + ln).join("\n"))((body) => `/**
${body}
 */`).go();
    }
  }
  Comment2.stringify = stringify;
})(Comment || (Comment = {}));

class CodeComposer {
  constructor(options) {
    this.plugins = [];
    this.options = options;
  }
  addPlugin(plugin) {
    const keyIndex = plugin.id ? this.plugins.findIndex((p) => p.id === plugin.id) : -1;
    if (keyIndex === -1) {
      this.plugins.push(plugin);
    } else {
      this.plugins.splice(keyIndex, 1, plugin);
    }
  }
  compose() {
    const blocks = new Blocks();
    const imports = new Imports();
    for (const plugin of this.plugins) {
      plugin.onCompose(blocks, imports, this.options);
    }
    if (imports.size > 0) {
      blocks.add(imports.getBlock());
    }
    return blocks.join();
  }
}

const declareConst = (name, value, exported = false, type = "") => `${cstr(exported, "export ")}const ${name}${cstr(!!type, `: ${type}`)} = ${value};`;
const declareInterface = (name, exported = false) => `${cstr(exported, "export ")}interface ${name} {}`;
const declareType = (name, exported = false) => `${cstr(exported, "export ")}type ${name} = {};`;
const declareFunction = (name, params = "", body = "", exported = false) => `${cstr(exported, "export ")}function ${name}(${params}) {${body ? `
${indent(body)}
` : " "}}`;
const createArrowFunction = (params = "", body = "") => `(${params}) => {${cstr(!!body, "\n" + indent(body) + "\n")}}`;
const createDefaultExport = (name) => `export default ${name};`;

const DECLARATION_BLOCK_KEY = "declaration";
const DECLARATION_BLOCK_PRECEDENCE = 10;
const TS_PROPS_BLOCK_KEY = "ts-prop-declaration";
const TS_PROPS_BLOCK_PRECEDENCE = 5;
const DEFAULT_EXPORT_BLOCK_KEY = "default-export";
const DEFAULT_EXPORT_BLOCK_PRECEDENCE = 20;
class JSXPlugin {
  constructor(options) {
    this.options = options;
    const { typescript, typescriptOptions } = options;
    if (typescript && !typescriptOptions) {
      throw TypeError("JSXPlugin requires Options.typescriptOptions to be set whenever Options.typescript is set");
    }
    this.typescriptOptions = typescriptOptions;
  }
  get propInterfaceName() {
    return this.options.name + "Props";
  }
  getComponentParams() {
    return this.options.typescript ? `props: ${this.propInterfaceName}` : "props";
  }
  getComponentBody() {
    return joinLines("", "return (", indent(`<${this.rootTag}></${this.rootTag}>`), ");");
  }
  getTSPropsDeclaration() {
    const { typescript } = this.options;
    if (!typescript) {
      throw new Error("getTSPropsDeclaration() called but typescript is false. This shouldn't be possible.");
    }
    const { propDeclaration } = this.typescriptOptions;
    switch (propDeclaration) {
      case "type":
        return declareType(this.propInterfaceName, true);
      case "interface":
        return declareInterface(this.propInterfaceName, true);
      default:
        return null;
    }
  }
  getComponentConstDeclaration() {
    const { name, componentOptions: { exportType } } = this.options;
    return declareConst(name, createArrowFunction(this.getComponentParams(), this.getComponentBody()), exportType === "named");
  }
  getComponentFunctionDeclaration() {
    const { name, componentOptions: { exportType } } = this.options;
    return declareFunction(name, this.getComponentParams(), this.getComponentBody(), exportType === "named");
  }
  getComponentDeclaration() {
    const { componentOptions: { declaration } } = this.options;
    return declaration === "const" ? this.getComponentConstDeclaration() : this.getComponentFunctionDeclaration();
  }
  onCompose(blocks, imports, options) {
    const { typescript, componentOptions: { exportType }, name } = this.options;
    this.declareImports(imports);
    if (typescript) {
      const propsDeclaration = this.getTSPropsDeclaration();
      if (propsDeclaration) {
        blocks.add({
          key: TS_PROPS_BLOCK_KEY,
          precedence: TS_PROPS_BLOCK_PRECEDENCE,
          data: propsDeclaration
        });
      }
    }
    blocks.add({
      key: DECLARATION_BLOCK_KEY,
      precedence: DECLARATION_BLOCK_PRECEDENCE,
      data: this.getComponentDeclaration()
    });
    if (exportType === "default") {
      blocks.add({
        key: DEFAULT_EXPORT_BLOCK_KEY,
        precedence: DEFAULT_EXPORT_BLOCK_PRECEDENCE,
        data: createDefaultExport(name)
      });
    }
  }
}

class ReactPlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "react";
    this.rootTag = "div";
    if (options.styling === Styling.STYLED_COMPONENTS) {
      this.rootTag = "Root";
    }
    const { reactOptions } = options;
    if (!reactOptions) {
      throw TypeError("ReactPlugin requires Options.reactOptions to be set");
    }
    this.reactOptions = reactOptions;
  }
  declareImports(imports) {
    if (this.reactOptions.importReact) {
      imports.add({ module: "react", defaultImport: "React" });
    }
  }
}

const RN_STYLING_BLOCK_KEY = "react-native-styling";
const RN_STYLING_BLOCK_PRECEDENCE = 7;
class ReactNativePlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "react-native";
    this.rootTag = "View";
    const { reactOptions, reactNativeOptions } = options;
    if (!reactOptions || !reactNativeOptions) {
      throw TypeError("ReactPlugin requires Options.reactOptions and Options.reactNativeOptions to be set");
    }
    this.reactOptions = reactOptions;
    this.reactNativeOptions = reactNativeOptions;
  }
  declareImports(imports) {
    if (this.reactOptions.importReact) {
      imports.add({ module: "react", defaultImport: "React" });
    }
    imports.add({ module: "react-native", namedImports: ["View"] });
    if (this.options.styling === Styling.REACT_NATIVE) {
      imports.add({ module: "react-native", namedImports: ["StyleSheet"] });
    }
  }
  onCompose(blocks, imports, options) {
    super.onCompose(blocks, imports, options);
    if (this.options.styling === Styling.REACT_NATIVE) {
      blocks.add({
        key: RN_STYLING_BLOCK_KEY,
        precedence: RN_STYLING_BLOCK_PRECEDENCE,
        data: declareConst("styles", "StyleSheet.create({})")
      });
    }
  }
}

class SolidPlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "solidjs";
    this.rootTag = "div";
    const solidjsOptions = options.solidjsOptions;
    if (!solidjsOptions) {
      throw TypeError("SolidPlugin requires Options.solidjsOptions to be set");
    }
    this.solidjsOptions = solidjsOptions;
  }
  declareImports() {
  }
}

class PreactPlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "preact";
    this.rootTag = "div";
    const preactOptions = options.preactOptions;
    if (!preactOptions) {
      throw TypeError("PreactPlugin requires Options.preactOptions to be set");
    }
    this.preactOptions = preactOptions;
  }
  declareImports() {
  }
}

class ImportPlugin {
  constructor(i) {
    this.import = i;
  }
  onCompose(blocks, imports, options) {
    imports.add(this.import);
  }
}

const frameworkTags = {
  [Framework.REACT]: "React",
  [Framework.REACT_NATIVE]: "React Native",
  [Framework.SOLIDJS]: "SolidJS",
  [Framework.PREACT]: "Preact"
};
const stylingTags = {
  [Styling.CSS]: "CSS",
  [Styling.SCSS]: "SCSS",
  [Styling.JSS]: "JSS",
  [Styling.STYLED_COMPONENTS]: "styled-components"
};
function getStackTags(options) {
  const { framework, styling, typescript } = options;
  const fwTag = frameworkTags[framework] ?? capitalize(framework);
  const typescriptTag = typescript ? "TypeScript" : void 0;
  const stylingTag = styling && stylingTags[styling];
  const stackTags = [
    fwTag,
    typescriptTag,
    stylingTag
  ].filter((tag) => !!tag);
  return stackTags;
}

const getDirPath = ({ baseDir, destination, name }) => resolve(baseDir ?? process.cwd(), destination, name);
const getFrameworkPlugin = (options, logger) => {
  switch (options.framework) {
    case Framework.REACT:
      return new ReactPlugin(options);
    case Framework.REACT_NATIVE:
      return new ReactNativePlugin(options);
    case Framework.SOLIDJS:
      return new SolidPlugin(options);
    case Framework.PREACT:
      return new PreactPlugin(options);
    default:
      {
        logger.warn("", "No framework flag was received, and Agrippa was unable to detect the framework automatically. Please check your configuration.");
        return null;
      }
  }
};
function defaultStyleFileImport(options, logger, styleFileName) {
  const { styling, name, styleFileOptions } = options;
  if (styling === Styling.CSS || styling === Styling.SCSS) {
    return {
      module: `./${styleFileName}`,
      defaultImport: styleFileOptions?.module ? "classes" : void 0
    };
  }
  if (styling === Styling.STYLED_COMPONENTS) {
    return {
      module: `./${name}.styles`,
      namedImports: ["Root"]
    };
  }
  logger.debug(`defaultStyleFileImport called for unknown styling option, ${styling}`);
  return void 0;
}
function defaultComponentFile(options, logger, additionalImports) {
  const { name, typescript } = options;
  const dirPath = getDirPath(options);
  const componentFileExtension = typescript ? "tsx" : "jsx";
  const componentFileName = `${name}.${componentFileExtension}`;
  const componentFilePath = join(dirPath, componentFileName);
  const composer = new CodeComposer(options);
  const frameworkPlugin = getFrameworkPlugin(options, logger);
  if (frameworkPlugin) {
    composer.addPlugin(frameworkPlugin);
  }
  additionalImports?.map((i) => {
    composer.addPlugin(new ImportPlugin(i));
  });
  return new AgrippaFile(componentFilePath, composer.compose());
}
function defaultIndexFile(options) {
  const { name, componentOptions: { exportType }, typescript } = options;
  const dirPath = getDirPath(options);
  const fileName = `index.${typescript ? "ts" : "js"}`;
  const path = join(dirPath, fileName);
  const code = joinLines(`export * from './${name}';`, exportType === "default" && `export { default } from './${name}';`);
  return new AgrippaFile(path, code);
}
function defaultPlugins(options, logger) {
  const { name, typescript, styling, styleFileOptions, createStylesFile } = options;
  const dirPath = getDirPath(options);
  const stylesFileName = styling === "styled-components" ? `${name}.styles.${typescript ? "ts" : "js"}` : `${kebabCase(name)}${styleFileOptions?.module ? ".module" : ""}.${styling}`;
  const styleFileContent = styling === "styled-components" ? joinLines(Import.stringify({ module: "styled-components", defaultImport: "styled" }), declareConst("Root", "styled.div``", true)) : "";
  const stylesFilePath = join(dirPath, stylesFileName);
  const styleFileImport = createStylesFile ? defaultStyleFileImport(options, logger, stylesFileName) : void 0;
  return [
    new StackTagPlugin(getStackTags(options)),
    new CreateDirPlugin({
      dir: new AgrippaDir(dirPath),
      varKey: "dirPath"
    }),
    new CreateFilePlugin({
      file: defaultComponentFile(options, logger, styleFileImport && [styleFileImport]),
      varKey: "componentPath"
    }),
    createStylesFile && new CreateFilePlugin({
      file: new AgrippaFile(stylesFilePath, styleFileContent),
      varKey: "stylesPath"
    }),
    new CreateFilePlugin({
      file: defaultIndexFile(options),
      varKey: "indexPath"
    })
  ].filter((p) => !!p);
}

class AsyncEventEmitter {
  constructor() {
    this.handlerMap = /* @__PURE__ */ Object.create(null);
  }
  addListener(event, handler) {
    if (!this.handlerMap[event]) {
      this.handlerMap[event] = /* @__PURE__ */ new Set();
    }
    this.handlerMap[event].add(handler);
  }
  on(event, handler) {
    return this.addListener(event, handler);
  }
  removeListener(event, handler) {
    this.handlerMap[event]?.delete(handler);
  }
  off(event, handler) {
    return this.removeListener(event, handler);
  }
  async emit(event, ...args) {
    const handlers = this.handlerMap[event];
    if (!handlers) {
      return;
    }
    for (const handler of handlers) {
      await handler(...args);
    }
  }
}

const parseJson = JSON5.parse;
const thisPath = typeof import.meta !== "undefined" ? dirname(fileURLToPath(import.meta.url)) : __dirname;
const pkgJsonPath = findUp.sync("package.json", { cwd: thisPath });
const pkgJson = parseJson(readFileSync(pkgJsonPath, "utf-8"));

class Context extends AsyncEventEmitter {
  constructor({
    options,
    plugins,
    stages = [],
    createdFiles = [],
    createdDirs = [],
    variables = {},
    logger,
    stackTags = []
  }) {
    super();
    this.version = pkgJson.version;
    this.logger = logger ?? Logger.create(options.pure, options.debug);
    this.stages = stages;
    this.stagesInitialized = false;
    this.options = options;
    this.plugins = plugins ?? defaultPlugins(options, this.logger);
    this.createdFiles = createdFiles;
    this.createdDirs = createdDirs;
    this.variables = variables;
    this.stackTags = stackTags;
    this.stackTagsInitialized = false;
    for (const plugin of this.plugins) {
      plugin._initialize(this);
    }
  }
  get pure() {
    return this.options.pure;
  }
  get debug() {
    return this.options.debug;
  }
  addStage(stage) {
    this.stages.push(stage);
  }
  async getStages() {
    if (!this.stagesInitialized) {
      this.logger.debug("Initializing stages...");
      await this.emit("create-stages");
      this.stagesInitialized = true;
      this.logger.debug("Initialized stages:", this.stages);
    }
    return this.stages;
  }
  addStackTag(tag) {
    this.stackTags.push(tag);
  }
  async getStackTags() {
    if (!this.stackTagsInitialized) {
      this.logger.debug("Initializing stack tags...");
      await this.emit("create-stack-tags");
      this.stackTagsInitialized = true;
      this.logger.debug("Initialized stack tags: ", this.stackTags);
    }
    return this.stackTags;
  }
  addPlugin(plugin) {
    this.plugins.push(plugin);
    plugin._initialize(this);
  }
  addFile(file) {
    this.createdFiles.push(file);
  }
  addDir(dir) {
    this.createdDirs.push(dir);
  }
  addVariable(key, value) {
    this.variables[key] = value;
  }
  async execute() {
    await this.getStages();
    await this.getStackTags();
    const logger = this.logger;
    logger.debug("Executing pipeline: running stages", "");
    await this.emit("pipeline-start");
    for (const stage of this.stages) {
      await this.emit("stage-start", stage);
      const stageLogger = new Logger();
      const result = await stage.execute(this, stageLogger);
      const stageLogs = stageLogger.consume();
      if (!stage.silent) {
        logger.info(summaryLine(result));
        logger.info(indent(styles.comment(stageLogs), 2, " ") + "\n");
      } else {
        logger.debug(stageLogs);
      }
      await this.emit("stage-end", stage);
    }
    await this.emit("pipeline-end");
    logger.debug("Pipeline execution complete.");
    const output = {
      options: this.options,
      plugins: this.plugins,
      stages: this.stages,
      createdFiles: this.createdFiles,
      createdDirs: this.createdDirs,
      variables: this.variables,
      stackTags: this.stackTags,
      logs: this.logger.consume()
    };
    return output;
  }
}

async function run(inputOptions, runOptions = {}) {
  const pure = !!inputOptions.pure;
  const debug = !!inputOptions.debug;
  const logger = runOptions.logger ?? Logger.create(pure, debug);
  logger.debug(runOptions.logger ? "Using logger passed in runOptions" : `Logger initialized with params pure=${pure}, debug=${debug}`);
  logger.debug(runOptions.envFiles?.agrippaConfig ? "Agrippa config passed through runOptions" : "Searching for agrippa.config.mjs...");
  const [config, configPath] = await loadFileQuery(runOptions.envFiles?.agrippaConfig ? { path: runOptions.envFiles?.agrippaConfig } : { search: "agrippa.config.mjs" });
  logger.debug("Resolved Agrippa config: ", config);
  const envFileQueries = Object.assign({}, config?.files, runOptions?.envFiles);
  const envFiles = Object.assign({ config }, !pure && await loadFiles(envFileQueries, dirname(configPath ?? "")));
  logger.debug("Resolved envFiles: ", envFiles);
  inputOptions = assignDefaults(config?.options ?? {}, inputOptions);
  const options = createOptions(inputOptions, envFiles);
  logger.debug("Resolved options: ", options);
  const context = new Context({
    options,
    variables: {
      "ComponentName": options.name,
      "component-name": kebabCase(options.name)
    },
    logger
  });
  runOptions.plugins?.forEach((p) => context.addPlugin(p));
  config?.plugins?.forEach((p) => context.addPlugin(p));
  if (options.lookForUpdates) {
    context.addPlugin(new UpdatesPlugin());
  } else {
    logger.debug("`options.lookForUpdates` is `false`, not pinging the npm registry");
  }
  if (options.reportTelemetry) {
    context.addPlugin(new TelemetryPlugin());
  } else {
    logger.debug("`options.reportTelemetry` is `false`, not sending usage statistics");
  }
  const stackTags = await context.getStackTags();
  logger.info("", `Agrippa v${context.version}`, "", `Generating ${styles.componentName(options.name)}
`, `Stack: ${stackTags.map((t) => styles.tag(t)).join(", ")}`, "");
  const output = await context.execute();
  logger.info("Generation successful. Cheers!");
  return output;
}

const cliLogger$1 = Logger.consoleLogger();
const builder$1 = async (yargs2) => yargs2.positional("name", {
  desc: "The name of the component to be generated",
  type: "string",
  demandOption: true
}).options({
  framework: {
    type: "string",
    alias: "fw",
    desc: "Which framework to generate the components for"
  },
  styling: {
    type: "string",
    desc: "Which styling solution to use"
  },
  "styling-module": {
    alias: "stylingModule",
    type: "boolean",
    desc: "Whether to generate a scoped `module` stylesheet. Relevant only for `css` or `scss` styling options."
  },
  typescript: {
    type: "boolean",
    alias: "ts",
    desc: "Whether to use Typescript"
  },
  "ts-props-declaration": {
    alias: "tsPropsDeclaration",
    choices: ["interface", "type"],
    desc: "For TS components, whether to declare props as an interface or a type"
  },
  "import-react": {
    alias: "importReact",
    type: "boolean",
    desc: "Whether to import React. Relevant only for `react` or `react-native`."
  },
  overwrite: {
    type: "boolean"
  },
  "base-dir": {
    alias: "baseDir",
    type: "string",
    desc: "Path to a base directory which components should be genenrated in or relative to."
  },
  destination: {
    alias: "dest",
    type: "string",
    desc: "The path in which the component folder/files should be generated, relative to baseDir."
  },
  "allow-outside-base": {
    alias: "allowOutsideBase",
    type: "boolean",
    desc: "If true, allows components to be generated outside the resolved baseDir."
  },
  "export-type": {
    alias: "exportType",
    choices: ["named", "default"],
    desc: "Whether to use a named export or a default export for the component."
  },
  "declaration": {
    choices: ["const", "function"],
    desc: "Whether to declare the component as a const with an arrow function or a function declaration."
  },
  "post-command": {
    alias: "postCommand",
    type: "string"
  },
  "debug": {
    type: "boolean"
  },
  "look-for-updates": {
    type: "boolean",
    alias: "lookForUpdates",
    desc: "Whether to look for updates when running Agrippa or not."
  },
  "report-telemetry": {
    type: "boolean",
    alias: "reportTelemetry",
    desc: "Whether to report (anonymous!) telemetry or not."
  }
}).middleware(({ debug = false }) => {
  if (debug) {
    process.env.IS_DEBUG = JSON.stringify(true);
    cliLogger$1.isDebug = true;
    cliLogger$1.debug("", "Agrippa CLI: Debug mode is ON");
  }
}, true);
const generateCommand = {
  command: "generate <name> [options]",
  aliases: ["gen"],
  describe: "Generate a component",
  builder: builder$1,
  handler: async (argv) => {
    const framework = Framework.fromString(argv.framework) ?? argv.framework;
    const styling = Styling.fromString(argv.styling) ?? argv.styling;
    cliLogger$1.debug(`Agrippa CLI: received a 'generate' command for component ${italic(argv.name)} with framework ${italic(framework)}`);
    cliLogger$1.debug("argv:", argv);
    const inputOptions = {
      name: argv.name,
      framework,
      typescript: argv.typescript,
      typescriptOptions: {
        propDeclaration: argv.tsPropsDeclaration
      },
      componentOptions: {
        exportType: argv.exportType,
        declaration: argv.declaration
      },
      reactOptions: {
        importReact: argv.importReact
      },
      styling,
      styleFileOptions: {
        module: argv.stylingModule
      },
      baseDir: argv.baseDir,
      destination: argv.destination,
      allowOutsideBase: argv.allowOutsideBase,
      debug: argv.debug,
      overwrite: argv.overwrite,
      reportTelemetry: argv.reportTelemetry,
      lookForUpdates: argv.lookForUpdates,
      pure: false
    };
    await run(inputOptions, {
      logger: cliLogger$1,
      plugins: argv.postCommand ? [new PostCommandPlugin(argv.postCommand)] : void 0
    });
  }
};

function getConfigTemplate(bare) {
  return bare ? joinLines("// @ts-check", "", "export default {", "  options: {}", "};") : joinLines("// @ts-check", "import { defineConfig } from 'agrippa';", "", "export default defineConfig({", "  options: {}", "});");
}

const cliLogger = Logger.consoleLogger();
const builder = (yargs) => yargs.options({
  bare: {
    type: "boolean",
    desc: "If passed, Agrippa will generate a config that does not import agrippa. This is used for global installations."
  }
});
const initCommand = {
  command: "init [options]",
  describe: "Initialize Agrippa's configuration for this project",
  builder,
  handler: async (argv) => {
    cliLogger.info("", `Agrippa v${pkgJson.version}`, "");
    const bare = argv.bare ?? await loadFileQuery({ search: "package.json" }).then(([pkg]) => !("agrippa" in pkg.devDependencies || "agrippa" in pkg.dependencies));
    if (bare) {
      cliLogger.warn(`${argv.bare ? "The `--bare` flag was passed" : "Agrippa was not detected as a local dependency"}. It's highly recommended to install agrippa as a dev dependency, rather than using it as a global package.`, 'Generating a "bare" config...', "");
    }
    const path = join(cwd(), "agrippa.config.mjs");
    cliLogger.info(`Generating a fresh Agrippa config at ${styles.path(path)}...
`);
    const fileContents = getConfigTemplate(bare);
    try {
      await writeFile(path, fileContents, { flag: "wx" });
      cliLogger.info(styles.success("Successfully generated!\n"));
    } catch (e) {
      if (e.code === "EEXIST") {
        cliLogger.error("An Agrippa config file `agrippa.config.mjs` already exists at the current working directory.\n");
      } else {
        throw e;
      }
    }
  }
};

const y = yargs(hideBin(process.argv));
y.scriptName("agrippa");
y.command(generateCommand);
y.command(initCommand);
y.command({
  command: ["$0"],
  handler: () => void y.showHelp()
});
y.recommendCommands().showHelpOnFail(false).strict();
y.parseAsync().catch(console.error);
