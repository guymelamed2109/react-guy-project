/// <reference types="graceful-fs" />
import EventEmitter from "events";
import chalk from "chalk";
declare enum Framework {
    REACT = "react",
    SOLIDJS = "solidjs",
    PREACT = "preact",
    REACT_NATIVE = "react-native"
}
declare namespace Framework {
    function fromString(str: string): Framework | null;
}
declare enum Styling {
    CSS = "css",
    SCSS = "scss",
    JSS = "jss",
    STYLED_COMPONENTS = "styled-components",
    REACT_NATIVE = "react-native"
}
declare namespace Styling {
    function fromString(str: string): Styling | null;
}
/**
 * Agrippa generation options.
 */
interface Options {
    /** Component's name, *in pascal case* */
    name: string;
    componentOptions: {
        exportType: "named" | "default";
        declaration: "const" | "function";
    };
    framework: Framework | string;
    reactOptions?: {
        importReact: boolean;
    };
    solidjsOptions?: {};
    preactOptions?: {};
    reactNativeOptions?: {};
    typescript: boolean;
    typescriptOptions?: {
        propDeclaration: "interface" | "type" | null;
    };
    styling?: Styling | string;
    createStylesFile: boolean;
    styleFileOptions?: {
        module: boolean;
    };
    baseDir: string;
    destination: string;
    allowOutsideBase: boolean;
    overwrite: boolean;
    pure: boolean;
    reportTelemetry: boolean;
    lookForUpdates: boolean;
    debug: boolean;
}
type Falsy = undefined | null | false | 0 | "";
/** Makes only the keys K of T optional */
type SemiPartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type DeepPartial<T> = T extends object ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : T;
type MaybePromise<T> = Promise<T> | T;
/** Simple util to render a string conditionally, or *null* if it is not met */
declare const ostr: (condition: boolean, string: string) => string | null;
/** Simple util to render a string conditionally, or *an empty string* if it is not met */
declare const cstr: (condition: boolean, string: string) => string;
/** Indents every line of the given string by `token`, `num` times.  */
declare const indent: (str: string, num?: number, token?: string) => string;
/** Joins `lines` with '\n', filtering any non-string value. Technically also supports code blocks that are more than one line.  */
declare const joinLines: (...lines: (string | false)[]) => string;
declare const isLowerCase: (str: string) => boolean;
/**
 * Turns the first letter of the string to upper case (and leaves the rest unchanged).
 */
declare const capitalize: (str: string) => string;
declare const isKebabCase: (str: string) => boolean;
declare const isCamelCase: (str: string) => boolean;
declare const isPascalCase: (str: string) => boolean;
declare const pascalCase: (str: string) => string;
declare const kebabCase: (str: string) => string;
interface InputOptions extends DeepPartial<Options> {
    name: string;
}
declare const defaultFramework: (packageJson: any) => Options["framework"];
declare function createOptions(input: InputOptions, envFiles: Record<string, any>): Options;
/**
 * Lists file types supported by loadFile, by their extension.
 */
declare enum FileType {
    JSON = "json",
    JS = "js",
    MJS = "mjs"
}
declare namespace FileType {
    const values: FileType[];
    function fromString(str: string): FileType | null;
}
type FileQuery = {
    path: string;
} | {
    search: string;
};
/**
 * Loads a file located at the given path, assuming it is of the given type.
 *
 * @param path the path to load the file from
 * @param type file type; if this is not specified, `loadFile` will try to guess
 * the file's type based on its extension.
 */
declare function loadFile<T>(path: string, type?: (FileType | string)): Promise<T>;
/**
 * Searches for a file by the given query; if found it is loaded (using `loadFile`), otherwise `null` is returned.
 *
 * @param query the query to search by; this is forwarded to `findUp`.
 * @param type optional file type; see `loadFile()`.
 */
declare function loadFileQuery<T>(query: FileQuery, type?: (FileType | string)): Promise<[
    data: T | null,
    path: string | null
]>;
type CustomFileQueries = Record<string, string | FileQuery | null>;
/**
 * Finds and loads files needed for Agrippa's process.
 *
 * By default, Agrippa searches for:
 * - "package.json" file (key `packageJson`)
 * - "tsconfig.json" (key `tsconfig`)
 *
 * This can be customized using the `customFileQueries` parameter.
 *
 * @param customFileQueries record of custom files to search for.
 * Its keys should be identifiers for the custom file lookups, and values should be
 * the file queries themselves (`string` | `string[]`, passed to `findUp`).
 * To disable Agrippa looking up one of its default files, its key can be passed with `null` here (e.g. `{ tsconfig: null }` disables tsconfig lookup).
 *
 * @param basePath base path to resolve all paths relative to.
 *
 * @returns The loaded files as a record whose keys are string identifiers of files, and values are the file's parsed contents (as JSON)'
 * paths and contents.
 * If a file was searched for and not found, it *will* have an entry in the record, with the corresponding value being `null`.
 */
declare function loadFiles(): Promise<Record<string, any>>;
declare function loadFiles(customFileQueries: CustomFileQueries, basePath: string): Promise<Record<string, any>>;
declare namespace Logger {
    type LogType = "info" | "debug" | "warning" | "error";
    interface Log {
        type: LogType;
        message: string;
    }
}
interface LoggerEvents extends Record<Logger.LogType, (message: string) => void> {
    "log": (log: Logger.Log) => void;
}
interface Logger {
    on<E extends keyof LoggerEvents>(event: E, listener: LoggerEvents[E]): this;
    emit<E extends keyof LoggerEvents>(event: E, ...args: Parameters<LoggerEvents[E]>): boolean;
}
/**
 * Logger class for Agrippa. This is a simple EventEmitter, with event for each of
 * the defined `Logger.LogType`s, as well as a generic `'log'` event.
 */
declare class Logger extends EventEmitter {
    /**
     * Returns a logger with a listener attached that pipes this logger's logs to the console.
     * All logs are sent to `stdout`, except for `Log`s of the `'error'` type, which are sent
     * to `stderr` instead.
     */
    static consoleLogger(isDebug?: boolean): Logger;
    static create(isPure: boolean, isDebug: boolean): Logger;
    isDebug: boolean;
    protected logs: Logger.Log[];
    constructor(isDebug?: boolean);
    protected format(args: unknown[], style?: (x: unknown) => unknown): string;
    log(type: Logger.LogType, message: string): void;
    debug(...data: any[]): void;
    info(...data: any[]): void;
    warn(...data: any[]): void;
    error(...data: any[]): void;
    /**
     * Consumes this logger: aggregates all accumulated logs to one string, which is returned,
     * and clears the inner logs. Typically, a logger is shouldn't used after being `consume`d,
     * but currently it does not break the logger's functionality.
     */
    consume(): string;
}
declare const styles: {
    componentName: chalk.Chalk;
    tag: chalk.Chalk;
    error: chalk.Chalk;
    warning: chalk.Chalk;
    debug: chalk.Chalk;
    success: chalk.Chalk;
    comment: chalk.Chalk;
    path: chalk.Chalk;
    bold: chalk.Chalk;
    italic: chalk.Chalk;
    NA: chalk.Chalk;
    command: chalk.Chalk;
};
declare const bold: chalk.Chalk, italic: chalk.Chalk;
type Handler = (...args: any[]) => MaybePromise<void>;
/**
 * An async variant of EventEmitter, that runs event handlers one by one (as an async waterfall).
 *
 * @todo find a better name
 */
declare class AsyncEventEmitter<EventMap extends Record<string, Handler>> {
    private handlerMap;
    addListener<K extends keyof EventMap>(event: K, handler: EventMap[K]): void;
    on<K extends keyof EventMap>(event: K, handler: EventMap[K]): void;
    removeListener<K extends keyof EventMap>(event: K, handler: EventMap[K]): void;
    off<K extends keyof EventMap>(event: K, handler: EventMap[K]): void;
    emit<K extends keyof EventMap>(event: K, ...args: Parameters<EventMap[K]>): Promise<void>;
}
declare class AgrippaDir {
    readonly path: string;
    constructor(path: string);
}
declare class AgrippaFile {
    readonly path: string;
    readonly data: string;
    constructor(path: string, data: string);
    get directory(): string;
    get extension(): string;
    get fileName(): string;
    toJSON(): string;
}
declare class StageResult {
    readonly status: StageStatus;
    readonly summary: string;
    constructor(status: StageStatus, summary: string);
}
declare enum StageStatus {
    SUCCESS = "success",
    WARNING = "warning",
    ERROR = "error",
    NA = "NA"
}
declare abstract class Stage {
    /** If set, logs are not printed for this stage (only as debug output) */
    silent: boolean;
    abstract execute(context: Context, logger: Logger): Promise<StageResult>;
}
interface RunOutput extends Pick<Context, "options" | "plugins" | "stages" | "createdFiles" | "createdDirs" | "variables" | "stackTags"> {
    logs: string;
}
interface ContextOptions {
    options: Options;
    plugins?: Plugin[];
    stages?: Stage[];
    createdFiles?: AgrippaFile[];
    createdDirs?: AgrippaDir[];
    variables?: Record<string, any>;
    logger?: Logger;
    stackTags?: string[];
}
type ContextEventMap = {
    "load": () => void;
    "create-stack-tags": () => void;
    "create-stages": () => void;
    "stage-start": (stage: Stage) => void;
    "stage-end": (stage: Stage) => void;
    "pipeline-start": () => void;
    "pipeline-end": () => void;
};
declare class Context extends AsyncEventEmitter<ContextEventMap> {
    readonly version: any;
    options: Options;
    readonly plugins: Plugin[];
    createdFiles: AgrippaFile[];
    createdDirs: AgrippaDir[];
    variables: Record<string, any>;
    stages: Stage[];
    stagesInitialized: boolean;
    stackTags: string[];
    stackTagsInitialized: boolean;
    readonly logger: Logger;
    constructor({ options, plugins, stages, createdFiles, createdDirs, variables, logger, stackTags }: ContextOptions);
    get pure(): boolean;
    get debug(): boolean;
    addStage(stage: Stage): void;
    getStages(): Promise<Stage[]>;
    addStackTag(tag: string): void;
    getStackTags(): Promise<string[]>;
    addPlugin(plugin: Plugin): void;
    addFile(file: AgrippaFile): void;
    addDir(dir: AgrippaDir): void;
    addVariable(key: string, value: any): void;
    execute(): Promise<RunOutput>;
}
/**
 * @todo describe events
 */
interface Plugin {
    context: Context;
    onContext?(): MaybePromise<void>;
    onCreateStages?(): MaybePromise<void>;
    onCreateStackTags?(): MaybePromise<void>;
    onStageStart?(): MaybePromise<void>;
    onStageEnd?(): MaybePromise<void>;
    onPipelineStart?(): MaybePromise<void>;
    onPipelineEnd?(): MaybePromise<void>;
}
declare class Plugin {
    constructor();
    _initialize(context: Context): void;
}
/**
 * A plugin that checks if a newer version of Agrippa exists.
 * Pings the npm registry and compares the latest version there to the version of this running instance.
 *
 * This plugin runs assuming updates are meant to be looked for; if that's not desired (in pure mode or if
 * the user disables it) the plugin shouldn't be registered.
 */
declare class UpdatesPlugin extends Plugin {
    private currentVersion;
    private requestPromise;
    private failed;
    pingRegistry(): Promise<string | undefined>;
    onPipelineStart(): void;
    onPipelineEnd(): Promise<void>;
}
/**
 * A plugin that report telemery (completely anonymously!).
 */
declare class TelemetryPlugin extends Plugin {
    onPipelineEnd(): Promise<void>;
}
interface CreateDirOptions {
    dir: AgrippaDir;
    recursive?: boolean;
    varKey?: string;
}
declare class CreateDirStage extends Stage {
    protected dir: AgrippaDir;
    /** Whether to recursively create this dir's parent directories, if necessary. Passed to `mkdir` */
    protected recursive: boolean;
    /**
     * If passed, stores the new directory's path under the context's `variables`
     * record with the passed value as key. Only stores the value if the stage succeeds.
     */
    protected varKey?: string;
    constructor({ dir, recursive, varKey }: CreateDirOptions);
    updateContext(context: Context): void;
    execute(context: Context, logger: Logger): Promise<StageResult>;
}
interface CreateFileOptions {
    file: AgrippaFile;
    varKey?: string;
}
declare class CreateFileStage extends Stage {
    protected file: AgrippaFile;
    /**
     * If passed, stores the new directory's path under the context's `variables`
     * record with the passed value as key. Only stores the value if the stage succeeds.
     */
    protected varKey?: string;
    constructor({ file, varKey }: CreateFileOptions);
    updateContext(context: Context): void;
    execute(context: Context, logger: Logger): Promise<StageResult>;
}
declare class CreateDirPlugin extends Plugin {
    dir: AgrippaDir;
    recursive: boolean | undefined;
    varKey: string | undefined;
    constructor({ dir, recursive, varKey }: CreateDirOptions);
    onCreateStages(): void;
}
declare class CreateFilePlugin extends Plugin {
    file: AgrippaFile;
    varKey: string | undefined;
    constructor({ file, varKey }: CreateFileOptions);
    onCreateStages(): void;
}
/**
 * A plugin that adds a post-command stage, i.e. a stage that runs any command.
 */
declare class PostCommandPlugin extends Plugin {
    protected readonly command: string;
    constructor(command: string);
    onCreateStages(): void;
}
/**
 * A plugin that defines one or more stack tags.
 */
declare class StackTagPlugin extends Plugin {
    tags: string[];
    constructor(tags: string[]);
    onCreateStackTags(): void;
}
interface Block {
    key: string;
    data: string;
    separator: string;
    precedence: number;
}
type BlockInput = SemiPartial<Block, "separator">;
declare class Blocks {
    protected readonly initialBlocks: Block[];
    protected readonly blocks: Map<string, Block>;
    constructor(initialBlocks?: Block[]);
    get(key: string): Block | undefined;
    add({ key, precedence, data, separator }: BlockInput): void;
    delete(key: string): boolean;
    join(): string;
}
interface Import {
    module: string;
    namedImports?: string[];
    defaultImport?: string;
}
declare namespace Import {
    /**
     * Forms the actual import code command from an Import object that represents it.
     *
     * @example
     * const i1 = Import.stringify({ module: 'react', defaultImport: 'React' });
     * console.log(i1); // "import React from 'react';"
     *
     * const i2 = Import.stringify({ module: 'react', namedImports: ['useState'] });
     * console.log(i2); // "import { useState } from 'react';"
     *
     * const i3 = Import.stringify({ module: 'react', defaultImport: 'React', namedImports: ['useState'] });
     * console.log(i3); // "import React, { useState } from 'react';"
     *
     * const i4 = Import.stringify({ module: './styles.css' });
     * console.log(i4); // "import './styles.css';"
     */
    function stringify(i: Import): string;
    /**
     * Merges two `Import`s. Merging imports only makes sense for imports of the same module;
     * if they are different, an error is thrown. Also, if both `Import`s contain default imports but they differ,
     * an error is thrown, as this seems to make no sense logically.
     */
    function merge(i1: Import, i2: Import): Import;
}
declare class Imports {
    static readonly BLOCK_KEY = "imports";
    static readonly BLOCK_PRECEDENCE: number;
    protected imports: Map<string, Import>;
    constructor();
    get(module: Import["module"]): Import | undefined;
    delete(module: Import["module"]): boolean;
    add(newImport: Import): void;
    get size(): number;
    getBlock(): Block;
}
/**
 * An object representing a code comment.
 *
 * @param type which comment the object represents. Options are:
 * - 'single': single line comment.
 * - 'block': block comment.
 * - 'jsdoc': JSDoc comment (starting with "/**").
 *
 * @param content comment contents. Does not have to be a single line, even if
 * the comment type is 'single' (in this case, the comment represented is comprised of
 * multiple single-line comments).
 */
interface Comment {
    type: "single" | "block" | "jsdoc";
    content: string;
}
declare namespace Comment {
    /**
     * Forms the actual comment code from a Comment object that represents it.
     *
     * @todo add examples
     */
    function stringify(c: Comment): string;
}
/**
 * Interface for a ComponentComposer plugin.
 */
interface ComposerPlugin {
    /**
     * optional plugin id; if set, it is used as a unique identifier to the plugin,
     * particularily implying no two plugins with the same id can be used simultaneously.
     */
    id?: string;
    /**
     * compose() hook; called when Composer.compose() is called to form the component code.
     */
    onCompose(blocks: Blocks, imports: Imports, options: Options): void;
}
/**
 * Base composer plugin for JSX components.
 */
declare abstract class JSXPlugin implements ComposerPlugin {
    protected options: Options;
    abstract readonly id?: string;
    abstract rootTag: string;
    protected typescriptOptions: Options["typescriptOptions"];
    constructor(options: Options);
    abstract declareImports(imports: Imports): void;
    get propInterfaceName(): string;
    getComponentParams(): string;
    getComponentBody(): string;
    getTSPropsDeclaration(): string | null;
    getComponentConstDeclaration(): string;
    getComponentFunctionDeclaration(): string;
    getComponentDeclaration(): string;
    // eslint-disable-next-line unused-imports/no-unused-vars
    onCompose(blocks: Blocks, imports: Imports, options: Options): void;
}
/**
 * ComponentComposer plugin for React components.
 */
declare class ReactPlugin extends JSXPlugin {
    protected options: Options;
    readonly id = "react";
    rootTag: string;
    private reactOptions;
    constructor(options: Options);
    declareImports(imports: Imports): void;
}
/** @todo find a better place for these */
declare const RN_STYLING_BLOCK_KEY = "react-native-styling";
declare const RN_STYLING_BLOCK_PRECEDENCE = 7;
declare class ReactNativePlugin extends JSXPlugin {
    protected options: Options;
    readonly id = "react-native";
    rootTag: string;
    private reactOptions;
    private reactNativeOptions;
    constructor(options: Options);
    declareImports(imports: Imports): void;
    onCompose(blocks: Blocks, imports: Imports, options: Options): void;
}
declare class SolidPlugin extends JSXPlugin {
    protected options: Options;
    readonly id = "solidjs";
    rootTag: string;
    private solidjsOptions;
    constructor(options: Options);
    declareImports(): void;
}
declare class PreactPlugin extends JSXPlugin {
    protected options: Options;
    readonly id = "preact";
    rootTag: string;
    private preactOptions;
    constructor(options: Options);
    declareImports(): void;
}
/**
 * A simple `ComponentComposer` plugin to add an import to the component.
 */
declare class ImportPlugin implements ComposerPlugin {
    readonly import: Import;
    constructor(i: Import);
    // eslint-disable-next-line unused-imports/no-unused-vars
    onCompose(blocks: Blocks, imports: Imports, options: Options): void;
}
/**
 * A composer plugin that adds a comment to a page.
 * Together with a Comment object, the plugin also expects
 * a key argument (identifying the comment block) and a precedece argument
 * (telling the composer where in the file to place the comment block).
 */
declare class CommentPlugin implements ComposerPlugin {
    protected readonly comment: Comment;
    protected readonly key: string;
    protected readonly precedence: number;
    constructor(comment: Comment, key: string, precedence: number);
    // eslint-disable-next-line unused-imports/no-unused-vars
    onCompose(blocks: Blocks, imports: Imports, options: Options): void;
}
declare class PropTypesPlugin implements ComposerPlugin {
    id: string;
    protected getPropTypesDeclaration(name: string): string;
    onCompose(blocks: Blocks, imports: Imports, options: Options): void;
}
/** @todo find a better place for these */
declare const TS_CHECK_BLOCK_KEY = "ts-check";
declare const TS_CHECK_BLOCK_PRECEDENCE = -1;
declare const DECLARATION_JSDOC_BLOCK_KEY = "declaration-jsdoc";
declare const DECLARATION_JSDOC_BLOCK_PRECEDENCE: number;
declare const PROPS_JSDOC_BLOCK_KEY = "props-jsdoc";
declare const PROPS_JSDOC_BLOCK_PRECEDENCE = 5;
interface JSDocPluginOptions {
    generateTypes?: boolean;
    includeTsCheck?: boolean;
    getCommentContent?: (options: Options) => string;
}
/**
 * A composer plugin for adding a JSDoc comment to the generated component,
 * or using JSDoc types (typically for type checking in JS files).
 */
declare class JSDocPlugin implements ComposerPlugin {
    id: string;
    protected readonly options: Options;
    protected readonly generateTypes: boolean;
    protected readonly includeTsCheck: boolean;
    protected readonly getCommentContent?: (options: Options) => string;
    /**
     * @param generateTypes Whether to generate
     * @param includeTsCheck Whether to include a ts-check statement at the top of the file.
     * By default, has the same value as `generateTypes`.
     */
    constructor(options: Options, { getCommentContent, generateTypes, includeTsCheck }?: JSDocPluginOptions);
    get propInterfaceName(): string;
    onCompose(blocks: Blocks, _: Imports): void;
}
/**
 * @todo description
 */
declare class CodeComposer {
    protected plugins: ComposerPlugin[];
    protected readonly options: Options;
    constructor(options: Options);
    addPlugin(plugin: ComposerPlugin): void;
    compose(): string;
}
declare const getFrameworkPlugin: (options: Options, logger: Logger) => ReactPlugin | ReactNativePlugin | SolidPlugin | PreactPlugin | null;
declare function defaultStyleFileImport(options: Options, logger: Logger, styleFileName: string): Import | undefined;
declare function defaultComponentFile(options: Options, logger: Logger, additionalImports?: Import[]): AgrippaFile;
declare function defaultIndexFile(options: Options): AgrippaFile;
declare function defaultPlugins(options: Options, logger: Logger): Plugin[];
type ConfigOptions = DeepPartial<Omit<Options, "name" | "createStyleFile" | "destination">>;
/**
 * Defines the structure of the default export of `agrippa.config.mjs`.
 */
interface Config {
    options?: ConfigOptions;
    plugins?: Plugin[];
    files?: CustomFileQueries;
}
/**
 * `defineConfig` is used in `agrippa.config.mjs` files,
 * for better typing intellisense.
 */
declare function defineConfig(config: Config): Config;
interface RunOptions {
    /** *paths* to envFiles that Agrippa should fetch */
    envFiles?: Record<string, string>;
    plugins?: Plugin[];
    logger?: Logger;
}
/**
 * Main Agrippa process.
 * Generates directories, files and file contents based on the given params.
 */
declare function run(inputOptions: InputOptions, runOptions?: RunOptions): Promise<RunOutput>;
export { RunOptions, run, Options, InputOptions, defaultFramework, createOptions, Framework, Styling, Config, defineConfig, Block, Blocks, Import, Imports, Comment, CodeComposer, ComposerPlugin, ReactPlugin, RN_STYLING_BLOCK_KEY, RN_STYLING_BLOCK_PRECEDENCE, ReactNativePlugin, SolidPlugin, PreactPlugin, ImportPlugin, CommentPlugin, PropTypesPlugin, TS_CHECK_BLOCK_KEY, TS_CHECK_BLOCK_PRECEDENCE, DECLARATION_JSDOC_BLOCK_KEY, DECLARATION_JSDOC_BLOCK_PRECEDENCE, PROPS_JSDOC_BLOCK_KEY, PROPS_JSDOC_BLOCK_PRECEDENCE, JSDocPluginOptions, JSDocPlugin, Logger, LoggerEvents, styles, bold, italic, Stage, CreateDirOptions, CreateDirStage, CreateFileOptions, CreateFileStage, AgrippaFile, AgrippaDir, ContextOptions, ContextEventMap, Context, RunOutput, FileType, FileQuery, loadFile, loadFileQuery, CustomFileQueries, loadFiles, Plugin, UpdatesPlugin, TelemetryPlugin, CreateDirPlugin, CreateFilePlugin, PostCommandPlugin, StackTagPlugin, getFrameworkPlugin, defaultStyleFileImport, defaultComponentFile, defaultIndexFile, defaultPlugins, Falsy, SemiPartial, DeepPartial, MaybePromise, ostr, cstr, indent, joinLines, isLowerCase, capitalize, isKebabCase, isCamelCase, isPascalCase, pascalCase, kebabCase };
//# sourceMappingURL=index.d.mts.map