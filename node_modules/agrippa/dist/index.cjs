'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var rhax = require('rhax');
var promises = require('fs/promises');
var process$1 = require('process');
var url = require('url');
var JSON5 = require('json5');
var findUp = require('find-up');
var EventEmitter = require('events');
var util = require('util');
var chalk = require('chalk');
var axios = require('axios');
var semver = require('semver');
var fs = require('fs');
var child_process = require('child_process');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var JSON5__default = /*#__PURE__*/_interopDefaultLegacy(JSON5);
var findUp__default = /*#__PURE__*/_interopDefaultLegacy(findUp);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var semver__default = /*#__PURE__*/_interopDefaultLegacy(semver);

const ostr = (condition, string) => {
  return condition ? string : null;
};
const cstr = (condition, string) => {
  return condition ? string : "";
};
const indent = (str, num = 1, token = "	") => {
  return str.split("\n").map((line) => token.repeat(num) + line).join("\n");
};
const joinLines = (...lines) => lines.filter((line) => typeof line === "string").join("\n");
const isLowerCase = (str) => str === str.toLocaleLowerCase();
const capitalize = (str) => str && str[0].toLocaleUpperCase() + str.slice(1);
const isKebabCase = (str) => str.split("-").every(isLowerCase);
const isCamelCase = (str) => !str || /^[a-z][A-Za-z\d]*$/.test(str);
const isPascalCase = (str) => !str || /^[A-Z][A-Za-z\d]*$/.test(str);
const pascalCase = (str) => {
  if (isPascalCase(str)) {
    return str;
  } else if (isCamelCase(str)) {
    return capitalize(str);
  } else if (isKebabCase(str)) {
    return str.split("-").map(capitalize).join("");
  }
  throw RangeError("Improper string formatting");
};
const kebabCase = (str) => {
  if (isPascalCase(str) || isCamelCase(str)) {
    return str.split(/(?=[A-Z])/).map((segment) => segment.toLocaleLowerCase()).join("-");
  } else if (isKebabCase(str)) {
    return str;
  }
  throw RangeError("Improper string formatting");
};

function assignDefaults(o1, o2) {
  for (const [key, value] of rhax.entries(o2)) {
    if (value === void 0) {
      continue;
    } else if (typeof value === "object" && value !== null) {
      if (typeof o1[key] !== "object" || o1[key] === null) {
        o1[key] = {};
      }
      assignDefaults(o1[key], value);
    } else {
      o1[key] = value;
    }
  }
  return o1;
}

exports.Framework = /* @__PURE__ */ ((Framework2) => {
  Framework2["REACT"] = "react";
  Framework2["SOLIDJS"] = "solidjs";
  Framework2["PREACT"] = "preact";
  Framework2["REACT_NATIVE"] = "react-native";
  return Framework2;
})(exports.Framework || {});
((Framework2) => {
  const values = [
    "react" /* REACT */,
    "solidjs" /* SOLIDJS */,
    "preact" /* PREACT */,
    "react-native" /* REACT_NATIVE */
  ];
  function fromString(str) {
    return values.find((fw) => fw === str) ?? null;
  }
  Framework2.fromString = fromString;
})(exports.Framework || (exports.Framework = {}));

exports.Styling = /* @__PURE__ */ ((Styling2) => {
  Styling2["CSS"] = "css";
  Styling2["SCSS"] = "scss";
  Styling2["JSS"] = "jss";
  Styling2["STYLED_COMPONENTS"] = "styled-components";
  Styling2["REACT_NATIVE"] = "react-native";
  return Styling2;
})(exports.Styling || {});
((Styling2) => {
  const values = [
    "css" /* CSS */,
    "scss" /* SCSS */,
    "jss" /* JSS */,
    "styled-components" /* STYLED_COMPONENTS */,
    "react-native" /* REACT_NATIVE */
  ];
  function fromString(str) {
    return values.find((sty) => sty === str) ?? null;
  }
  Styling2.fromString = fromString;
})(exports.Styling || (exports.Styling = {}));

const defaultFramework = (packageJson) => {
  const dependencies = packageJson?.dependencies ?? {};
  if ("react-native" in dependencies) {
    return exports.Framework.REACT_NATIVE;
  } else if ("preact" in dependencies) {
    return exports.Framework.PREACT;
  } else if ("solid-js" in dependencies) {
    return exports.Framework.SOLIDJS;
  } else if ("react" in dependencies) {
    return exports.Framework.REACT;
  }
  return "";
};
function createOptions(input, envFiles) {
  const { packageJson, tsconfig } = envFiles;
  const { styling } = input;
  const name = pascalCase(input.name);
  input.name = name;
  const framework = input.framework ?? defaultFramework(packageJson);
  const createStylesFile = [exports.Styling.CSS, exports.Styling.SCSS, exports.Styling.STYLED_COMPONENTS].includes(styling);
  const defaults = {
    name,
    componentOptions: {
      exportType: "named",
      declaration: "const"
    },
    framework,
    reactOptions: framework === exports.Framework.REACT || framework === exports.Framework.REACT_NATIVE ? {
      importReact: false
    } : void 0,
    solidjsOptions: framework === exports.Framework.SOLIDJS ? {} : void 0,
    preactOptions: framework === exports.Framework.PREACT ? {} : void 0,
    reactNativeOptions: framework === exports.Framework.REACT_NATIVE ? {} : void 0,
    typescript: !!tsconfig,
    typescriptOptions: !!tsconfig || input.typescript ? {
      propDeclaration: "interface"
    } : void 0,
    styling,
    createStylesFile,
    styleFileOptions: createStylesFile ? {
      module: true
    } : void 0,
    baseDir: process.cwd(),
    destination: ".",
    allowOutsideBase: false,
    overwrite: false,
    pure: false,
    reportTelemetry: true,
    lookForUpdates: true,
    debug: false
  };
  return assignDefaults(defaults, input);
}

function defineConfig(config) {
  return config;
}

const parseJson$1 = JSON5__default["default"].parse;
exports.FileType = /* @__PURE__ */ ((FileType2) => {
  FileType2["JSON"] = "json";
  FileType2["JS"] = "js";
  FileType2["MJS"] = "mjs";
  return FileType2;
})(exports.FileType || {});
((FileType2) => {
  FileType2.values = ["json" /* JSON */, "js" /* JS */, "mjs" /* MJS */];
  function fromString(str) {
    return FileType2.values.find((type) => type === str) ?? null;
  }
  FileType2.fromString = fromString;
})(exports.FileType || (exports.FileType = {}));
async function loadFile(path$1, type) {
  const extension = path.extname(path$1).slice(1);
  if (type && !exports.FileType.fromString(type)) {
    throw new Error(`Unsupported file type: ${type}. loadFiles supports only the following file types: ${exports.FileType.values.join(", ")}`);
  }
  const fileType = type ?? exports.FileType.fromString(extension);
  if (!fileType) {
    throw new Error(`A type was not passed, and could not be determined from the file path (${path$1})`);
  }
  const resolvedPath = path.resolve(process$1.cwd(), path$1);
  switch (fileType) {
    case "json" /* JSON */:
      return parseJson$1(await promises.readFile(resolvedPath, "utf8"));
    case "js" /* JS */:
      return (await (function (t) { return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(t)); }); })(url.pathToFileURL(resolvedPath).toString())).default;
    case "mjs" /* MJS */:
      return (await (function (t) { return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(t)); }); })(url.pathToFileURL(resolvedPath).toString())).default;
  }
}
async function loadFileQuery(query, type) {
  const path = "path" in query ? query.path : await findUp__default["default"](query.search);
  if (!path) {
    return [null, null];
  }
  return [await loadFile(path, type), path];
}

const defaultFileQueries = {
  packageJson: { search: "package.json" },
  tsconfig: { search: "tsconfig.json" }
};
async function loadFiles(customFileQueries = {}, basePath = ".") {
  const fileQueries = rhax.pipe({ ...defaultFileQueries, ...customFileQueries })(rhax.entries)(rhax.filter(([, f]) => !!f))(rhax.map(([k, val]) => rhax.tuple(k, typeof val === "string" ? { path: val } : val)))(rhax.map(([k, val]) => rhax.tuple(k, "path" in val ? { path: path.resolve(basePath, val.path) } : val)))(rhax.toObject).go();
  const filePromises = rhax.pipe(fileQueries)(rhax.entries)(rhax.map(([name, query]) => loadFileQuery(query).then(([f]) => rhax.tuple(name, f)))).go();
  const files = rhax.toObject(await Promise.all(filePromises));
  return files;
}

const styles = {
  componentName: chalk__default["default"].hex("#FCD558").bold,
  tag: chalk__default["default"].hex("#00D8FF").bold,
  error: chalk__default["default"].red,
  warning: chalk__default["default"].hex("#FFD307"),
  debug: chalk__default["default"].cyan,
  success: chalk__default["default"].green,
  comment: chalk__default["default"].gray,
  path: chalk__default["default"].gray.italic,
  bold: chalk__default["default"].bold,
  italic: chalk__default["default"].italic,
  NA: chalk__default["default"].hex("#B6B6B6"),
  command: chalk__default["default"].magenta
};
const { bold, italic } = styles;

class Logger extends EventEmitter__default["default"] {
  constructor(isDebug = false) {
    super();
    this.logs = [];
    this.isDebug = isDebug;
    this.on("error", () => {
    });
  }
  static consoleLogger(isDebug = false) {
    const logger = new Logger(isDebug);
    logger.on("log", ({ type, message }) => void (type === "error" ? console.error : console.log)(message));
    return logger;
  }
  static create(isPure, isDebug) {
    return isPure ? new Logger(isDebug) : Logger.consoleLogger(isDebug);
  }
  format(args, style = (x) => x) {
    return args.map((msg) => util.formatWithOptions({ colors: true }, msg)).map((msg) => style(msg)).join("\n");
  }
  log(type, message) {
    const logObject = { type, message };
    this.logs.push(logObject);
    this.emit("log", logObject);
    this.emit(type, message);
  }
  debug(...data) {
    if (this.isDebug) {
      const message = this.format(data, styles.debug);
      this.log("debug", message);
    }
  }
  info(...data) {
    const message = this.format(data);
    this.log("info", message);
  }
  warn(...data) {
    const message = this.format(data, styles.warning);
    this.log("warning", message);
  }
  error(...data) {
    const message = this.format(data, styles.error);
    this.log("error", message);
  }
  consume() {
    const logs = this.logs;
    this.logs = [];
    return logs.map((l) => l.message).join("\n");
  }
}

class Plugin {
  constructor() {
  }
  _initialize(context) {
    this.context = context;
    this.onContext?.();
    this.onCreateStackTags && context.addListener("create-stack-tags", this.onCreateStackTags.bind(this));
    this.onCreateStages && context.addListener("create-stages", this.onCreateStages.bind(this));
    this.onStageStart && context.addListener("stage-start", this.onStageStart.bind(this));
    this.onStageEnd && context.addListener("stage-end", this.onStageEnd.bind(this));
    this.onPipelineStart && context.addListener("pipeline-start", this.onPipelineStart.bind(this));
    this.onPipelineEnd && context.addListener("pipeline-end", this.onPipelineEnd.bind(this));
  }
}

const { diff, gt, lt } = semver__default["default"];
const AGRIPPA_NPM_ENDPOINT = "https://registry.npmjs.org/agrippa/latest";
class UpdatesPlugin extends Plugin {
  constructor() {
    super(...arguments);
    this.currentVersion = void 0;
    this.requestPromise = null;
    this.failed = false;
  }
  async pingRegistry() {
    const { logger } = this.context;
    logger.debug("UpdatesPlugin: pinging the npm registry");
    const sendTime = Date.now();
    try {
      const res = await axios__default["default"].get(AGRIPPA_NPM_ENDPOINT, {
        timeout: 5e3
      });
      const endTime = Date.now();
      logger.debug(`UpdatesPlugin: request resolved with status ${res.status}, took ${endTime - sendTime}ms`);
      const latestVersion = res.data.version;
      return latestVersion;
    } catch (e) {
      logger.debug(`UpdatesPlugin - ${e.code === "ECONNABORTED" ? "pinging the NPM registry timed out." : "pinging the NPM registry failed."}`);
      this.failed = true;
      logger.debug(e);
      return;
    }
  }
  onPipelineStart() {
    this.currentVersion = this.context.version;
    this.requestPromise = this.pingRegistry();
  }
  async onPipelineEnd() {
    const { logger } = this.context;
    const currentVersion = this.currentVersion;
    const latestVersion = await this.requestPromise;
    if (this.failed) {
      return;
    }
    logger.debug(`Current version: ${italic(currentVersion)}, Latest version: ${italic(latestVersion)}`);
    if (!currentVersion || !latestVersion) {
      logger.warn("Error in UpdatesPlugin: currentVersion or latestVersion are not set.");
      return;
    }
    if (gt(latestVersion, currentVersion)) {
      const df = diff(latestVersion, currentVersion);
      logger.info(bold(`New ${df} version available: ${latestVersion}!`), bold(`please update now by typing ${styles.command("npm i -g agrippa")} into the terminal`));
    } else if (lt(latestVersion, currentVersion)) {
      logger.debug("Current version is greater than the latest stable release");
    }
  }
}

const TELEMETRY_ENDPOINT = "https://agrippa-report-worker.nitzanhen.workers.dev/";
class TelemetryPlugin extends Plugin {
  async onPipelineEnd() {
    const { options, logger, version } = this.context;
    const runData = {
      ...rhax.pick(options, "framework", "typescript", "styling"),
      version
    };
    const sendTime = Date.now();
    try {
      logger.debug("TelemetryPlugin: sending report...");
      await axios__default["default"].post(TELEMETRY_ENDPOINT, runData, {
        timeout: options.debug ? 0 : 1
      }).catch((e) => {
        if (!options.debug && e.code === "ECONNABORTED") {
          return;
        }
        throw e;
      });
      const endTime = Date.now();
      logger.debug(`TelemetryPlugin: received response in ${endTime - sendTime}ms.`);
    } catch (e) {
      const endTime = Date.now();
      logger.debug(`TelemetryPlugin: request failed after ${endTime - sendTime}ms. Error:`);
      logger.debug(e);
    }
  }
}

class Stage {
  constructor() {
    this.silent = false;
  }
}

function isSubDirectory(parent, dir) {
  if (parent === dir) {
    return true;
  }
  const relativePath = path__default["default"].relative(parent, dir);
  return !!relativePath && !relativePath.startsWith("..") && !path__default["default"].isAbsolute(relativePath);
}

class StageResult {
  constructor(status, summary) {
    this.status = status;
    this.summary = summary;
  }
}
const stageStatusBullets = {
  success: "\u2713",
  warning: "\u2713",
  error: "\u2717",
  NA: "\u2022"
};
var StageStatus = /* @__PURE__ */ ((StageStatus2) => {
  StageStatus2["SUCCESS"] = "success";
  StageStatus2["WARNING"] = "warning";
  StageStatus2["ERROR"] = "error";
  StageStatus2["NA"] = "NA";
  return StageStatus2;
})(StageStatus || {});
const summaryLine = ({ status, summary }) => styles[status].bold(`${stageStatusBullets[status]} ${summary}`);

class CreateDirStage extends Stage {
  constructor({
    dir,
    recursive = true,
    varKey
  }) {
    super();
    this.dir = dir;
    this.recursive = recursive;
    this.varKey = varKey;
  }
  updateContext(context) {
    context.addDir(this.dir);
    if (this.varKey) {
      context.addVariable(this.varKey, this.dir.path);
    }
  }
  async execute(context, logger) {
    const { options } = context;
    const { pure, baseDir, allowOutsideBase, overwrite } = options;
    const { path: path$1 } = this.dir;
    const dirName = path.basename(path$1);
    if (pure) {
      this.updateContext(context);
      return new StageResult(StageStatus.NA, "No directory created (pure mode)");
    }
    if (baseDir && !isSubDirectory(baseDir, path$1) && !allowOutsideBase) {
      logger.error(joinLines(`The resolved path for the directory ${italic(dirName)} falls outside the base directory.`, `Base directory: ${italic(baseDir)}`, `Resolved directory: ${italic(path$1)}`, "To allow this behaviour, pass the '--allow-outside-base' flag or set 'allowOutsideBase: true' in agrippa.config.mjs"));
      return new StageResult(StageStatus.ERROR, "Directory path outside baseDir");
    }
    logger.info(`path: ${styles.path(path$1)}`);
    if (fs.existsSync(path$1) && !overwrite) {
      logger.info(`To allow overwriting, pass ${bold("--overwrite")} to the command.`);
      return new StageResult(StageStatus.ERROR, `Directory ${italic(dirName)} already exists.`);
    }
    try {
      await promises.mkdir(path$1, { recursive: this.recursive });
      this.updateContext(context);
      return new StageResult(StageStatus.SUCCESS, `Directory ${italic(dirName)} created successfully.`);
    } catch (e) {
      logger.error(e);
      return new StageResult(StageStatus.ERROR, `Creation of directory ${dirName} failed.`);
    }
  }
}

class CreateFileStage extends Stage {
  constructor({
    file,
    varKey
  }) {
    super();
    this.file = file;
    this.varKey = varKey;
  }
  updateContext(context) {
    context.addFile(this.file);
    if (this.varKey) {
      context.addVariable(this.varKey, this.file.path);
    }
  }
  async execute(context, logger) {
    const { options } = context;
    const { pure, baseDir, allowOutsideBase, overwrite } = options;
    const { data, path: path$1 } = this.file;
    if (pure) {
      this.updateContext(context);
      return new StageResult(StageStatus.NA, "No file created (pure mode)");
    }
    const filename = path.basename(path$1);
    if (baseDir && !isSubDirectory(baseDir, path$1) && !allowOutsideBase) {
      logger.error(joinLines(`The resolved path for the directory ${italic(filename)} falls outside the base directory.`, `Base directory: ${italic(baseDir)}`, `Resolved directory: ${italic(path$1)}`, "To allow this behaviour, pass the '--allow-outside-base' flag or set 'allowOutsideBase: true' in agrippa.config.mjs"));
      return new StageResult(StageStatus.ERROR, "Directory path outside baseDir");
    }
    logger.info(`path: ${styles.path(path$1)}`);
    if (fs.existsSync(path$1)) {
      if (!overwrite) {
        logger.info(`To allow overwriting, pass ${bold("--overwrite")} to the command.`);
        return new StageResult(StageStatus.ERROR, `File ${italic(filename)} already exists.`);
      }
      logger.info("File exists, and was overwritten.");
    }
    try {
      await promises.writeFile(path$1, data);
      this.updateContext(context);
      return new StageResult(StageStatus.SUCCESS, `File ${italic(filename)} created successfully.`);
    } catch (e) {
      logger.error(e);
      return new StageResult(StageStatus.ERROR, `Creation of file ${filename} failed.`);
    }
  }
}

class AgrippaFile {
  constructor(path, data) {
    this.path = path;
    this.data = data;
  }
  get directory() {
    return path.dirname(this.path);
  }
  get extension() {
    return path.extname(this.path);
  }
  get fileName() {
    return path.basename(this.path, this.extension);
  }
  toJSON() {
    return JSON.stringify({
      path: this.path,
      data: this.data,
      directory: this.directory,
      extension: this.extension,
      fileName: this.fileName
    });
  }
}

class AgrippaDir {
  constructor(path) {
    this.path = path;
  }
}

class CreateDirPlugin extends Plugin {
  constructor({
    dir,
    recursive,
    varKey
  }) {
    super();
    this.dir = dir;
    this.recursive = recursive;
    this.varKey = varKey;
  }
  onCreateStages() {
    this.context.addStage(new CreateDirStage({
      dir: this.dir,
      recursive: this.recursive,
      varKey: this.varKey
    }));
  }
}

class CreateFilePlugin extends Plugin {
  constructor({
    file,
    varKey
  }) {
    super();
    this.file = file;
    this.varKey = varKey;
  }
  onCreateStages() {
    this.context.addStage(new CreateFileStage({
      file: this.file,
      varKey: this.varKey
    }));
  }
}

const exec = util.promisify(child_process.exec);
class RunCommandStage extends Stage {
  constructor({
    rawCommand
  }) {
    super();
    this.rawCommand = rawCommand;
  }
  async execute(context, logger) {
    logger.debug("runCommand: initiated");
    logger.debug(`Raw command (before substituting variables): ${this.rawCommand}`);
    const { variables } = context;
    logger.debug("Context variables:", variables);
    const command = rhax.reduce.object(variables, (cmd, value, key) => cmd.replace(`<${key}>`, value), this.rawCommand);
    logger.debug(`Command (after substituting variables): ${command}`);
    try {
      const { stdout, stderr } = await exec(command);
      if (stderr) {
        throw new Error(stderr);
      }
      logger.info(stdout ? `output: ${stdout}` : "No output received from command.");
      return new StageResult(StageStatus.SUCCESS, "Post command successfully executed");
    } catch (e) {
      logger.error(e);
      return new StageResult(StageStatus.ERROR, "Post command failed");
    }
  }
}

class PostCommandPlugin extends Plugin {
  constructor(command) {
    super();
    this.command = command;
  }
  onCreateStages() {
    this.context.addStage(new RunCommandStage({ rawCommand: this.command }));
  }
}

class StackTagPlugin extends Plugin {
  constructor(tags) {
    super();
    this.tags = tags;
  }
  onCreateStackTags() {
    for (const tag of this.tags) {
      this.context.addStackTag(tag);
    }
  }
}

class Blocks {
  constructor(initialBlocks = []) {
    this.initialBlocks = initialBlocks;
    const keyBlockPairs = initialBlocks.map((b) => rhax.tuple(b.key, b));
    this.blocks = new Map(keyBlockPairs);
  }
  get(key) {
    return this.blocks.get(key);
  }
  add({ key, precedence, data, separator = "\n\n" }) {
    this.blocks.set(key, { key, precedence, data, separator });
  }
  delete(key) {
    return this.blocks.delete(key);
  }
  join() {
    if (this.blocks.size === 0) {
      return "";
    }
    const blocksSorted = [...this.blocks.values()].sort((b1, b2) => b1.precedence - b2.precedence);
    const head = blocksSorted.slice(0, -1);
    const last = blocksSorted[blocksSorted.length - 1];
    return [
      ...head.map(({ data, separator }) => data + separator),
      last.data
    ].join("");
  }
}

exports.Import = void 0;
((Import2) => {
  function stringify(i) {
    const { module, namedImports, defaultImport } = i;
    const namedString = namedImports?.length ? `{ ${namedImports?.join(", ")} }` : null;
    return `import ${defaultImport ?? ""}${cstr(!!defaultImport && !!namedString, ", ")}${namedString ?? ""}${cstr(!!defaultImport || !!namedString, " from ")}'${module}';`;
  }
  Import2.stringify = stringify;
  function merge(i1, i2) {
    if (i1.module !== i2.module) {
      throw new RangeError("Illogical merge: both imports must refer to the same module");
    }
    const module = i1.module;
    const default1 = i1.defaultImport;
    const default2 = i2.defaultImport;
    const named1 = i1.namedImports ?? [];
    const named2 = i2.namedImports ?? [];
    if (default1 && default2 && default1 !== default2) {
      throw new RangeError("Illogical merge: cannot merge two different default imports.");
    }
    const defaultImport = default1 ?? default2;
    const namedImports = [...named1, ...named2];
    return {
      module,
      defaultImport,
      namedImports: namedImports.length > 0 ? namedImports : void 0
    };
  }
  Import2.merge = merge;
})(exports.Import || (exports.Import = {}));

const _Imports = class {
  constructor() {
    this.imports = /* @__PURE__ */ new Map();
  }
  get(module) {
    return this.imports.get(module);
  }
  delete(module) {
    return this.imports.delete(module);
  }
  add(newImport) {
    const module = newImport.module;
    const oldImport = this.imports.get(module);
    const i = oldImport ? exports.Import.merge(oldImport, newImport) : newImport;
    this.imports.set(module, i);
  }
  get size() {
    return this.imports.size;
  }
  getBlock() {
    const data = [...this.imports.values()].map(exports.Import.stringify).join("\n") + "\n";
    return {
      key: _Imports.BLOCK_KEY,
      precedence: _Imports.BLOCK_PRECEDENCE,
      data,
      separator: "\n"
    };
  }
};
let Imports = _Imports;
Imports.BLOCK_KEY = "imports";
Imports.BLOCK_PRECEDENCE = -Number.EPSILON;

exports.Comment = void 0;
((Comment2) => {
  function stringify(c) {
    switch (c.type) {
      case "single":
        return c.content.split("\n").map((ln) => `// ${ln}`).join("");
      case "block":
        return rhax.pipe(c.content)((data) => data.split("\n").map((ln) => " * " + ln).join("\n"))((body) => `/*
${body}
 */`).go();
      case "jsdoc":
        return rhax.pipe(c.content)((data) => data.split("\n").map((ln) => " * " + ln).join("\n"))((body) => `/**
${body}
 */`).go();
    }
  }
  Comment2.stringify = stringify;
})(exports.Comment || (exports.Comment = {}));

class CodeComposer {
  constructor(options) {
    this.plugins = [];
    this.options = options;
  }
  addPlugin(plugin) {
    const keyIndex = plugin.id ? this.plugins.findIndex((p) => p.id === plugin.id) : -1;
    if (keyIndex === -1) {
      this.plugins.push(plugin);
    } else {
      this.plugins.splice(keyIndex, 1, plugin);
    }
  }
  compose() {
    const blocks = new Blocks();
    const imports = new Imports();
    for (const plugin of this.plugins) {
      plugin.onCompose(blocks, imports, this.options);
    }
    if (imports.size > 0) {
      blocks.add(imports.getBlock());
    }
    return blocks.join();
  }
}

const declareConst = (name, value, exported = false, type = "") => `${cstr(exported, "export ")}const ${name}${cstr(!!type, `: ${type}`)} = ${value};`;
const declareInterface = (name, exported = false) => `${cstr(exported, "export ")}interface ${name} {}`;
const declareType = (name, exported = false) => `${cstr(exported, "export ")}type ${name} = {};`;
const declareFunction = (name, params = "", body = "", exported = false) => `${cstr(exported, "export ")}function ${name}(${params}) {${body ? `
${indent(body)}
` : " "}}`;
const createArrowFunction = (params = "", body = "") => `(${params}) => {${cstr(!!body, "\n" + indent(body) + "\n")}}`;
const createDefaultExport = (name) => `export default ${name};`;
const createAssignment = (target, key, value) => `${target}.${key} = ${value};`;

const DECLARATION_BLOCK_KEY = "declaration";
const DECLARATION_BLOCK_PRECEDENCE = 10;
const TS_PROPS_BLOCK_KEY = "ts-prop-declaration";
const TS_PROPS_BLOCK_PRECEDENCE = 5;
const DEFAULT_EXPORT_BLOCK_KEY = "default-export";
const DEFAULT_EXPORT_BLOCK_PRECEDENCE = 20;
class JSXPlugin {
  constructor(options) {
    this.options = options;
    const { typescript, typescriptOptions } = options;
    if (typescript && !typescriptOptions) {
      throw TypeError("JSXPlugin requires Options.typescriptOptions to be set whenever Options.typescript is set");
    }
    this.typescriptOptions = typescriptOptions;
  }
  get propInterfaceName() {
    return this.options.name + "Props";
  }
  getComponentParams() {
    return this.options.typescript ? `props: ${this.propInterfaceName}` : "props";
  }
  getComponentBody() {
    return joinLines("", "return (", indent(`<${this.rootTag}></${this.rootTag}>`), ");");
  }
  getTSPropsDeclaration() {
    const { typescript } = this.options;
    if (!typescript) {
      throw new Error("getTSPropsDeclaration() called but typescript is false. This shouldn't be possible.");
    }
    const { propDeclaration } = this.typescriptOptions;
    switch (propDeclaration) {
      case "type":
        return declareType(this.propInterfaceName, true);
      case "interface":
        return declareInterface(this.propInterfaceName, true);
      default:
        return null;
    }
  }
  getComponentConstDeclaration() {
    const { name, componentOptions: { exportType } } = this.options;
    return declareConst(name, createArrowFunction(this.getComponentParams(), this.getComponentBody()), exportType === "named");
  }
  getComponentFunctionDeclaration() {
    const { name, componentOptions: { exportType } } = this.options;
    return declareFunction(name, this.getComponentParams(), this.getComponentBody(), exportType === "named");
  }
  getComponentDeclaration() {
    const { componentOptions: { declaration } } = this.options;
    return declaration === "const" ? this.getComponentConstDeclaration() : this.getComponentFunctionDeclaration();
  }
  onCompose(blocks, imports, options) {
    const { typescript, componentOptions: { exportType }, name } = this.options;
    this.declareImports(imports);
    if (typescript) {
      const propsDeclaration = this.getTSPropsDeclaration();
      if (propsDeclaration) {
        blocks.add({
          key: TS_PROPS_BLOCK_KEY,
          precedence: TS_PROPS_BLOCK_PRECEDENCE,
          data: propsDeclaration
        });
      }
    }
    blocks.add({
      key: DECLARATION_BLOCK_KEY,
      precedence: DECLARATION_BLOCK_PRECEDENCE,
      data: this.getComponentDeclaration()
    });
    if (exportType === "default") {
      blocks.add({
        key: DEFAULT_EXPORT_BLOCK_KEY,
        precedence: DEFAULT_EXPORT_BLOCK_PRECEDENCE,
        data: createDefaultExport(name)
      });
    }
  }
}

class ReactPlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "react";
    this.rootTag = "div";
    if (options.styling === exports.Styling.STYLED_COMPONENTS) {
      this.rootTag = "Root";
    }
    const { reactOptions } = options;
    if (!reactOptions) {
      throw TypeError("ReactPlugin requires Options.reactOptions to be set");
    }
    this.reactOptions = reactOptions;
  }
  declareImports(imports) {
    if (this.reactOptions.importReact) {
      imports.add({ module: "react", defaultImport: "React" });
    }
  }
}

const RN_STYLING_BLOCK_KEY = "react-native-styling";
const RN_STYLING_BLOCK_PRECEDENCE = 7;
class ReactNativePlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "react-native";
    this.rootTag = "View";
    const { reactOptions, reactNativeOptions } = options;
    if (!reactOptions || !reactNativeOptions) {
      throw TypeError("ReactPlugin requires Options.reactOptions and Options.reactNativeOptions to be set");
    }
    this.reactOptions = reactOptions;
    this.reactNativeOptions = reactNativeOptions;
  }
  declareImports(imports) {
    if (this.reactOptions.importReact) {
      imports.add({ module: "react", defaultImport: "React" });
    }
    imports.add({ module: "react-native", namedImports: ["View"] });
    if (this.options.styling === exports.Styling.REACT_NATIVE) {
      imports.add({ module: "react-native", namedImports: ["StyleSheet"] });
    }
  }
  onCompose(blocks, imports, options) {
    super.onCompose(blocks, imports, options);
    if (this.options.styling === exports.Styling.REACT_NATIVE) {
      blocks.add({
        key: RN_STYLING_BLOCK_KEY,
        precedence: RN_STYLING_BLOCK_PRECEDENCE,
        data: declareConst("styles", "StyleSheet.create({})")
      });
    }
  }
}

class SolidPlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "solidjs";
    this.rootTag = "div";
    const solidjsOptions = options.solidjsOptions;
    if (!solidjsOptions) {
      throw TypeError("SolidPlugin requires Options.solidjsOptions to be set");
    }
    this.solidjsOptions = solidjsOptions;
  }
  declareImports() {
  }
}

class PreactPlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "preact";
    this.rootTag = "div";
    const preactOptions = options.preactOptions;
    if (!preactOptions) {
      throw TypeError("PreactPlugin requires Options.preactOptions to be set");
    }
    this.preactOptions = preactOptions;
  }
  declareImports() {
  }
}

class ImportPlugin {
  constructor(i) {
    this.import = i;
  }
  onCompose(blocks, imports, options) {
    imports.add(this.import);
  }
}

class CommentPlugin {
  constructor(comment, key, precedence) {
    this.comment = comment;
    this.key = key;
    this.precedence = precedence;
  }
  onCompose(blocks, imports, options) {
    blocks.add({
      key: this.key,
      precedence: this.precedence,
      data: exports.Comment.stringify(this.comment)
    });
  }
}

const PROP_TYPES_BLOCK_KEY = "prop-types";
const PROP_TYPES_BLOCK_PRECEDENCE = 15;
class PropTypesPlugin {
  constructor() {
    this.id = "prop-types";
  }
  getPropTypesDeclaration(name) {
    return createAssignment(name, "propTypes", "{}");
  }
  onCompose(blocks, imports, options) {
    const { name } = options;
    imports.add({
      module: "prop-types",
      defaultImport: "PropTypes"
    });
    blocks.add({
      key: PROP_TYPES_BLOCK_KEY,
      precedence: PROP_TYPES_BLOCK_PRECEDENCE,
      data: this.getPropTypesDeclaration(name)
    });
  }
}

const TS_CHECK_BLOCK_KEY = "ts-check";
const TS_CHECK_BLOCK_PRECEDENCE = -1;
const DECLARATION_JSDOC_BLOCK_KEY = "declaration-jsdoc";
const DECLARATION_JSDOC_BLOCK_PRECEDENCE = DECLARATION_BLOCK_PRECEDENCE - 1;
const PROPS_JSDOC_BLOCK_KEY = "props-jsdoc";
const PROPS_JSDOC_BLOCK_PRECEDENCE = 5;
class JSDocPlugin {
  constructor(options, {
    getCommentContent,
    generateTypes = false,
    includeTsCheck = generateTypes
  } = {}) {
    this.id = "jsdoc";
    this.options = options;
    this.getCommentContent = getCommentContent;
    this.generateTypes = generateTypes;
    this.includeTsCheck = includeTsCheck;
  }
  get propInterfaceName() {
    return this.options.name + "Props";
  }
  onCompose(blocks, _) {
    if (this.includeTsCheck) {
      blocks.add({
        key: TS_CHECK_BLOCK_KEY,
        precedence: TS_CHECK_BLOCK_PRECEDENCE,
        data: exports.Comment.stringify({ type: "single", content: "@ts-check" }),
        separator: "\n"
      });
    }
    if (this.generateTypes) {
      blocks.add({
        key: PROPS_JSDOC_BLOCK_KEY,
        precedence: PROPS_JSDOC_BLOCK_PRECEDENCE,
        data: exports.Comment.stringify({ type: "jsdoc", content: `@typedef {Object} ${this.propInterfaceName}` })
      });
    }
    const commentContent = this.getCommentContent?.(this.options) ?? "";
    const commentString = commentContent + cstr(this.generateTypes, `
@param {${this.propInterfaceName}} props`);
    blocks.add({
      key: DECLARATION_JSDOC_BLOCK_KEY,
      precedence: DECLARATION_JSDOC_BLOCK_PRECEDENCE,
      data: exports.Comment.stringify({ type: "jsdoc", content: commentString }),
      separator: "\n"
    });
  }
}

const frameworkTags = {
  [exports.Framework.REACT]: "React",
  [exports.Framework.REACT_NATIVE]: "React Native",
  [exports.Framework.SOLIDJS]: "SolidJS",
  [exports.Framework.PREACT]: "Preact"
};
const stylingTags = {
  [exports.Styling.CSS]: "CSS",
  [exports.Styling.SCSS]: "SCSS",
  [exports.Styling.JSS]: "JSS",
  [exports.Styling.STYLED_COMPONENTS]: "styled-components"
};
function getStackTags(options) {
  const { framework, styling, typescript } = options;
  const fwTag = frameworkTags[framework] ?? capitalize(framework);
  const typescriptTag = typescript ? "TypeScript" : void 0;
  const stylingTag = styling && stylingTags[styling];
  const stackTags = [
    fwTag,
    typescriptTag,
    stylingTag
  ].filter((tag) => !!tag);
  return stackTags;
}

const getDirPath = ({ baseDir, destination, name }) => path.resolve(baseDir ?? process.cwd(), destination, name);
const getFrameworkPlugin = (options, logger) => {
  switch (options.framework) {
    case exports.Framework.REACT:
      return new ReactPlugin(options);
    case exports.Framework.REACT_NATIVE:
      return new ReactNativePlugin(options);
    case exports.Framework.SOLIDJS:
      return new SolidPlugin(options);
    case exports.Framework.PREACT:
      return new PreactPlugin(options);
    default:
      {
        logger.warn("", "No framework flag was received, and Agrippa was unable to detect the framework automatically. Please check your configuration.");
        return null;
      }
  }
};
function defaultStyleFileImport(options, logger, styleFileName) {
  const { styling, name, styleFileOptions } = options;
  if (styling === exports.Styling.CSS || styling === exports.Styling.SCSS) {
    return {
      module: `./${styleFileName}`,
      defaultImport: styleFileOptions?.module ? "classes" : void 0
    };
  }
  if (styling === exports.Styling.STYLED_COMPONENTS) {
    return {
      module: `./${name}.styles`,
      namedImports: ["Root"]
    };
  }
  logger.debug(`defaultStyleFileImport called for unknown styling option, ${styling}`);
  return void 0;
}
function defaultComponentFile(options, logger, additionalImports) {
  const { name, typescript } = options;
  const dirPath = getDirPath(options);
  const componentFileExtension = typescript ? "tsx" : "jsx";
  const componentFileName = `${name}.${componentFileExtension}`;
  const componentFilePath = path.join(dirPath, componentFileName);
  const composer = new CodeComposer(options);
  const frameworkPlugin = getFrameworkPlugin(options, logger);
  if (frameworkPlugin) {
    composer.addPlugin(frameworkPlugin);
  }
  additionalImports?.map((i) => {
    composer.addPlugin(new ImportPlugin(i));
  });
  return new AgrippaFile(componentFilePath, composer.compose());
}
function defaultIndexFile(options) {
  const { name, componentOptions: { exportType }, typescript } = options;
  const dirPath = getDirPath(options);
  const fileName = `index.${typescript ? "ts" : "js"}`;
  const path$1 = path.join(dirPath, fileName);
  const code = joinLines(`export * from './${name}';`, exportType === "default" && `export { default } from './${name}';`);
  return new AgrippaFile(path$1, code);
}
function defaultPlugins(options, logger) {
  const { name, typescript, styling, styleFileOptions, createStylesFile } = options;
  const dirPath = getDirPath(options);
  const stylesFileName = styling === "styled-components" ? `${name}.styles.${typescript ? "ts" : "js"}` : `${kebabCase(name)}${styleFileOptions?.module ? ".module" : ""}.${styling}`;
  const styleFileContent = styling === "styled-components" ? joinLines(exports.Import.stringify({ module: "styled-components", defaultImport: "styled" }), declareConst("Root", "styled.div``", true)) : "";
  const stylesFilePath = path.join(dirPath, stylesFileName);
  const styleFileImport = createStylesFile ? defaultStyleFileImport(options, logger, stylesFileName) : void 0;
  return [
    new StackTagPlugin(getStackTags(options)),
    new CreateDirPlugin({
      dir: new AgrippaDir(dirPath),
      varKey: "dirPath"
    }),
    new CreateFilePlugin({
      file: defaultComponentFile(options, logger, styleFileImport && [styleFileImport]),
      varKey: "componentPath"
    }),
    createStylesFile && new CreateFilePlugin({
      file: new AgrippaFile(stylesFilePath, styleFileContent),
      varKey: "stylesPath"
    }),
    new CreateFilePlugin({
      file: defaultIndexFile(options),
      varKey: "indexPath"
    })
  ].filter((p) => !!p);
}

class AsyncEventEmitter {
  constructor() {
    this.handlerMap = /* @__PURE__ */ Object.create(null);
  }
  addListener(event, handler) {
    if (!this.handlerMap[event]) {
      this.handlerMap[event] = /* @__PURE__ */ new Set();
    }
    this.handlerMap[event].add(handler);
  }
  on(event, handler) {
    return this.addListener(event, handler);
  }
  removeListener(event, handler) {
    this.handlerMap[event]?.delete(handler);
  }
  off(event, handler) {
    return this.removeListener(event, handler);
  }
  async emit(event, ...args) {
    const handlers = this.handlerMap[event];
    if (!handlers) {
      return;
    }
    for (const handler of handlers) {
      await handler(...args);
    }
  }
}

const parseJson = JSON5__default["default"].parse;
const thisPath = typeof ({ url: (typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('index.cjs', document.baseURI).href)) }) !== "undefined" ? path.dirname(url.fileURLToPath((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('index.cjs', document.baseURI).href)))) : __dirname;
const pkgJsonPath = findUp__default["default"].sync("package.json", { cwd: thisPath });
const pkgJson = parseJson(fs.readFileSync(pkgJsonPath, "utf-8"));

class Context extends AsyncEventEmitter {
  constructor({
    options,
    plugins,
    stages = [],
    createdFiles = [],
    createdDirs = [],
    variables = {},
    logger,
    stackTags = []
  }) {
    super();
    this.version = pkgJson.version;
    this.logger = logger ?? Logger.create(options.pure, options.debug);
    this.stages = stages;
    this.stagesInitialized = false;
    this.options = options;
    this.plugins = plugins ?? defaultPlugins(options, this.logger);
    this.createdFiles = createdFiles;
    this.createdDirs = createdDirs;
    this.variables = variables;
    this.stackTags = stackTags;
    this.stackTagsInitialized = false;
    for (const plugin of this.plugins) {
      plugin._initialize(this);
    }
  }
  get pure() {
    return this.options.pure;
  }
  get debug() {
    return this.options.debug;
  }
  addStage(stage) {
    this.stages.push(stage);
  }
  async getStages() {
    if (!this.stagesInitialized) {
      this.logger.debug("Initializing stages...");
      await this.emit("create-stages");
      this.stagesInitialized = true;
      this.logger.debug("Initialized stages:", this.stages);
    }
    return this.stages;
  }
  addStackTag(tag) {
    this.stackTags.push(tag);
  }
  async getStackTags() {
    if (!this.stackTagsInitialized) {
      this.logger.debug("Initializing stack tags...");
      await this.emit("create-stack-tags");
      this.stackTagsInitialized = true;
      this.logger.debug("Initialized stack tags: ", this.stackTags);
    }
    return this.stackTags;
  }
  addPlugin(plugin) {
    this.plugins.push(plugin);
    plugin._initialize(this);
  }
  addFile(file) {
    this.createdFiles.push(file);
  }
  addDir(dir) {
    this.createdDirs.push(dir);
  }
  addVariable(key, value) {
    this.variables[key] = value;
  }
  async execute() {
    await this.getStages();
    await this.getStackTags();
    const logger = this.logger;
    logger.debug("Executing pipeline: running stages", "");
    await this.emit("pipeline-start");
    for (const stage of this.stages) {
      await this.emit("stage-start", stage);
      const stageLogger = new Logger();
      const result = await stage.execute(this, stageLogger);
      const stageLogs = stageLogger.consume();
      if (!stage.silent) {
        logger.info(summaryLine(result));
        logger.info(indent(styles.comment(stageLogs), 2, " ") + "\n");
      } else {
        logger.debug(stageLogs);
      }
      await this.emit("stage-end", stage);
    }
    await this.emit("pipeline-end");
    logger.debug("Pipeline execution complete.");
    const output = {
      options: this.options,
      plugins: this.plugins,
      stages: this.stages,
      createdFiles: this.createdFiles,
      createdDirs: this.createdDirs,
      variables: this.variables,
      stackTags: this.stackTags,
      logs: this.logger.consume()
    };
    return output;
  }
}

async function run(inputOptions, runOptions = {}) {
  const pure = !!inputOptions.pure;
  const debug = !!inputOptions.debug;
  const logger = runOptions.logger ?? Logger.create(pure, debug);
  logger.debug(runOptions.logger ? "Using logger passed in runOptions" : `Logger initialized with params pure=${pure}, debug=${debug}`);
  logger.debug(runOptions.envFiles?.agrippaConfig ? "Agrippa config passed through runOptions" : "Searching for agrippa.config.mjs...");
  const [config, configPath] = await loadFileQuery(runOptions.envFiles?.agrippaConfig ? { path: runOptions.envFiles?.agrippaConfig } : { search: "agrippa.config.mjs" });
  logger.debug("Resolved Agrippa config: ", config);
  const envFileQueries = Object.assign({}, config?.files, runOptions?.envFiles);
  const envFiles = Object.assign({ config }, !pure && await loadFiles(envFileQueries, path.dirname(configPath ?? "")));
  logger.debug("Resolved envFiles: ", envFiles);
  inputOptions = assignDefaults(config?.options ?? {}, inputOptions);
  const options = createOptions(inputOptions, envFiles);
  logger.debug("Resolved options: ", options);
  const context = new Context({
    options,
    variables: {
      "ComponentName": options.name,
      "component-name": kebabCase(options.name)
    },
    logger
  });
  runOptions.plugins?.forEach((p) => context.addPlugin(p));
  config?.plugins?.forEach((p) => context.addPlugin(p));
  if (options.lookForUpdates) {
    context.addPlugin(new UpdatesPlugin());
  } else {
    logger.debug("`options.lookForUpdates` is `false`, not pinging the npm registry");
  }
  if (options.reportTelemetry) {
    context.addPlugin(new TelemetryPlugin());
  } else {
    logger.debug("`options.reportTelemetry` is `false`, not sending usage statistics");
  }
  const stackTags = await context.getStackTags();
  logger.info("", `Agrippa v${context.version}`, "", `Generating ${styles.componentName(options.name)}
`, `Stack: ${stackTags.map((t) => styles.tag(t)).join(", ")}`, "");
  const output = await context.execute();
  logger.info("Generation successful. Cheers!");
  return output;
}

exports.AgrippaDir = AgrippaDir;
exports.AgrippaFile = AgrippaFile;
exports.Blocks = Blocks;
exports.CodeComposer = CodeComposer;
exports.CommentPlugin = CommentPlugin;
exports.Context = Context;
exports.CreateDirPlugin = CreateDirPlugin;
exports.CreateDirStage = CreateDirStage;
exports.CreateFilePlugin = CreateFilePlugin;
exports.CreateFileStage = CreateFileStage;
exports.DECLARATION_JSDOC_BLOCK_KEY = DECLARATION_JSDOC_BLOCK_KEY;
exports.DECLARATION_JSDOC_BLOCK_PRECEDENCE = DECLARATION_JSDOC_BLOCK_PRECEDENCE;
exports.ImportPlugin = ImportPlugin;
exports.Imports = Imports;
exports.JSDocPlugin = JSDocPlugin;
exports.Logger = Logger;
exports.PROPS_JSDOC_BLOCK_KEY = PROPS_JSDOC_BLOCK_KEY;
exports.PROPS_JSDOC_BLOCK_PRECEDENCE = PROPS_JSDOC_BLOCK_PRECEDENCE;
exports.Plugin = Plugin;
exports.PostCommandPlugin = PostCommandPlugin;
exports.PreactPlugin = PreactPlugin;
exports.PropTypesPlugin = PropTypesPlugin;
exports.RN_STYLING_BLOCK_KEY = RN_STYLING_BLOCK_KEY;
exports.RN_STYLING_BLOCK_PRECEDENCE = RN_STYLING_BLOCK_PRECEDENCE;
exports.ReactNativePlugin = ReactNativePlugin;
exports.ReactPlugin = ReactPlugin;
exports.SolidPlugin = SolidPlugin;
exports.StackTagPlugin = StackTagPlugin;
exports.Stage = Stage;
exports.TS_CHECK_BLOCK_KEY = TS_CHECK_BLOCK_KEY;
exports.TS_CHECK_BLOCK_PRECEDENCE = TS_CHECK_BLOCK_PRECEDENCE;
exports.TelemetryPlugin = TelemetryPlugin;
exports.UpdatesPlugin = UpdatesPlugin;
exports.bold = bold;
exports.capitalize = capitalize;
exports.createOptions = createOptions;
exports.cstr = cstr;
exports.defaultComponentFile = defaultComponentFile;
exports.defaultFramework = defaultFramework;
exports.defaultIndexFile = defaultIndexFile;
exports.defaultPlugins = defaultPlugins;
exports.defaultStyleFileImport = defaultStyleFileImport;
exports.defineConfig = defineConfig;
exports.getFrameworkPlugin = getFrameworkPlugin;
exports.indent = indent;
exports.isCamelCase = isCamelCase;
exports.isKebabCase = isKebabCase;
exports.isLowerCase = isLowerCase;
exports.isPascalCase = isPascalCase;
exports.italic = italic;
exports.joinLines = joinLines;
exports.kebabCase = kebabCase;
exports.loadFile = loadFile;
exports.loadFileQuery = loadFileQuery;
exports.loadFiles = loadFiles;
exports.ostr = ostr;
exports.pascalCase = pascalCase;
exports.run = run;
exports.styles = styles;
