import path, { extname, resolve, basename, dirname, join } from 'path';
import { entries, pipe, filter, map, tuple, toObject, pick, reduce } from 'rhax';
import { readFile, mkdir, writeFile } from 'fs/promises';
import { cwd } from 'process';
import { pathToFileURL, fileURLToPath } from 'url';
import JSON5 from 'json5';
import findUp from 'find-up';
import EventEmitter from 'events';
import { formatWithOptions, promisify } from 'util';
import chalk from 'chalk';
import axios from 'axios';
import semver from 'semver';
import { existsSync, readFileSync } from 'fs';
import { exec as exec$1 } from 'child_process';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const ostr = (condition, string) => {
  return condition ? string : null;
};
const cstr = (condition, string) => {
  return condition ? string : "";
};
const indent = (str, num = 1, token = "	") => {
  return str.split("\n").map((line) => token.repeat(num) + line).join("\n");
};
const joinLines = (...lines) => lines.filter((line) => typeof line === "string").join("\n");
const isLowerCase = (str) => str === str.toLocaleLowerCase();
const capitalize = (str) => str && str[0].toLocaleUpperCase() + str.slice(1);
const isKebabCase = (str) => str.split("-").every(isLowerCase);
const isCamelCase = (str) => !str || /^[a-z][A-Za-z\d]*$/.test(str);
const isPascalCase = (str) => !str || /^[A-Z][A-Za-z\d]*$/.test(str);
const pascalCase = (str) => {
  if (isPascalCase(str)) {
    return str;
  } else if (isCamelCase(str)) {
    return capitalize(str);
  } else if (isKebabCase(str)) {
    return str.split("-").map(capitalize).join("");
  }
  throw RangeError("Improper string formatting");
};
const kebabCase = (str) => {
  if (isPascalCase(str) || isCamelCase(str)) {
    return str.split(/(?=[A-Z])/).map((segment) => segment.toLocaleLowerCase()).join("-");
  } else if (isKebabCase(str)) {
    return str;
  }
  throw RangeError("Improper string formatting");
};

function assignDefaults(o1, o2) {
  for (const [key, value] of entries(o2)) {
    if (value === void 0) {
      continue;
    } else if (typeof value === "object" && value !== null) {
      if (typeof o1[key] !== "object" || o1[key] === null) {
        o1[key] = {};
      }
      assignDefaults(o1[key], value);
    } else {
      o1[key] = value;
    }
  }
  return o1;
}

var Framework;
(function(Framework2) {
  Framework2["REACT"] = "react";
  Framework2["SOLIDJS"] = "solidjs";
  Framework2["PREACT"] = "preact";
  Framework2["REACT_NATIVE"] = "react-native";
})(Framework || (Framework = {}));
(function(Framework2) {
  const values = [
    Framework2.REACT,
    Framework2.SOLIDJS,
    Framework2.PREACT,
    Framework2.REACT_NATIVE
  ];
  function fromString(str) {
    var _a;
    return (_a = values.find((fw) => fw === str)) !== null && _a !== void 0 ? _a : null;
  }
  Framework2.fromString = fromString;
})(Framework || (Framework = {}));

var Styling;
(function(Styling2) {
  Styling2["CSS"] = "css";
  Styling2["SCSS"] = "scss";
  Styling2["JSS"] = "jss";
  Styling2["STYLED_COMPONENTS"] = "styled-components";
  Styling2["REACT_NATIVE"] = "react-native";
})(Styling || (Styling = {}));
(function(Styling2) {
  const values = [
    Styling2.CSS,
    Styling2.SCSS,
    Styling2.JSS,
    Styling2.STYLED_COMPONENTS,
    Styling2.REACT_NATIVE
  ];
  function fromString(str) {
    var _a;
    return (_a = values.find((sty) => sty === str)) !== null && _a !== void 0 ? _a : null;
  }
  Styling2.fromString = fromString;
})(Styling || (Styling = {}));

const defaultFramework = (packageJson) => {
  var _a;
  const dependencies = (_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.dependencies) !== null && _a !== void 0 ? _a : {};
  if ("react-native" in dependencies) {
    return Framework.REACT_NATIVE;
  } else if ("preact" in dependencies) {
    return Framework.PREACT;
  } else if ("solid-js" in dependencies) {
    return Framework.SOLIDJS;
  } else if ("react" in dependencies) {
    return Framework.REACT;
  }
  return "";
};
function createOptions(input, envFiles) {
  var _a;
  const { packageJson, tsconfig } = envFiles;
  const { styling } = input;
  const name = pascalCase(input.name);
  input.name = name;
  const framework = (_a = input.framework) !== null && _a !== void 0 ? _a : defaultFramework(packageJson);
  const createStylesFile = [Styling.CSS, Styling.SCSS, Styling.STYLED_COMPONENTS].includes(styling);
  const defaults = {
    name,
    componentOptions: {
      exportType: "named",
      declaration: "const"
    },
    framework,
    reactOptions: framework === Framework.REACT || framework === Framework.REACT_NATIVE ? {
      importReact: false
    } : void 0,
    solidjsOptions: framework === Framework.SOLIDJS ? {} : void 0,
    preactOptions: framework === Framework.PREACT ? {} : void 0,
    reactNativeOptions: framework === Framework.REACT_NATIVE ? {} : void 0,
    typescript: !!tsconfig,
    typescriptOptions: !!tsconfig || input.typescript ? {
      propDeclaration: "interface"
    } : void 0,
    styling,
    createStylesFile,
    styleFileOptions: createStylesFile ? {
      module: true
    } : void 0,
    baseDir: process.cwd(),
    destination: ".",
    allowOutsideBase: false,
    overwrite: false,
    pure: false,
    reportTelemetry: true,
    lookForUpdates: true,
    debug: false
  };
  return assignDefaults(defaults, input);
}

function defineConfig(config) {
  return config;
}

const parseJson$1 = JSON5.parse;
var FileType;
(function(FileType2) {
  FileType2["JSON"] = "json";
  FileType2["JS"] = "js";
  FileType2["MJS"] = "mjs";
})(FileType || (FileType = {}));
(function(FileType2) {
  FileType2.values = [FileType2.JSON, FileType2.JS, FileType2.MJS];
  function fromString(str) {
    var _a;
    return (_a = FileType2.values.find((type) => type === str)) !== null && _a !== void 0 ? _a : null;
  }
  FileType2.fromString = fromString;
})(FileType || (FileType = {}));
function loadFile(path, type) {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const extension = extname(path).slice(1);
    if (type && !FileType.fromString(type)) {
      throw new Error(`Unsupported file type: ${type}. loadFiles supports only the following file types: ${FileType.values.join(", ")}`);
    }
    const fileType = (_a = type) !== null && _a !== void 0 ? _a : FileType.fromString(extension);
    if (!fileType) {
      throw new Error(`A type was not passed, and could not be determined from the file path (${path})`);
    }
    const resolvedPath = resolve(cwd(), path);
    switch (fileType) {
      case FileType.JSON:
        return parseJson$1(yield readFile(resolvedPath, "utf8"));
      case FileType.JS:
        return (yield import(pathToFileURL(resolvedPath).toString())).default;
      case FileType.MJS:
        return (yield import(pathToFileURL(resolvedPath).toString())).default;
    }
  });
}
function loadFileQuery(query, type) {
  return __awaiter(this, void 0, void 0, function* () {
    const path = "path" in query ? query.path : yield findUp(query.search);
    if (!path) {
      return [null, null];
    }
    return [yield loadFile(path, type), path];
  });
}

const defaultFileQueries = {
  packageJson: { search: "package.json" },
  tsconfig: { search: "tsconfig.json" }
};
function loadFiles(customFileQueries = {}, basePath = ".") {
  return __awaiter(this, void 0, void 0, function* () {
    const fileQueries = pipe(Object.assign(Object.assign({}, defaultFileQueries), customFileQueries))(entries)(filter(([, f]) => !!f))(map(([k, val]) => tuple(k, typeof val === "string" ? { path: val } : val)))(map(([k, val]) => tuple(k, "path" in val ? { path: resolve(basePath, val.path) } : val)))(toObject).go();
    const filePromises = pipe(fileQueries)(entries)(map(([name, query]) => loadFileQuery(query).then(([f]) => tuple(name, f)))).go();
    const files = toObject(yield Promise.all(filePromises));
    return files;
  });
}

const styles = {
  componentName: chalk.hex("#FCD558").bold,
  tag: chalk.hex("#00D8FF").bold,
  error: chalk.red,
  warning: chalk.hex("#FFD307"),
  debug: chalk.cyan,
  success: chalk.green,
  comment: chalk.gray,
  path: chalk.gray.italic,
  bold: chalk.bold,
  italic: chalk.italic,
  NA: chalk.hex("#B6B6B6"),
  command: chalk.magenta
};
const { bold, italic } = styles;

class Logger extends EventEmitter {
  constructor(isDebug = false) {
    super();
    this.logs = [];
    this.isDebug = isDebug;
    this.on("error", () => {
    });
  }
  static consoleLogger(isDebug = false) {
    const logger = new Logger(isDebug);
    logger.on("log", ({ type, message }) => void (type === "error" ? console.error : console.log)(message));
    return logger;
  }
  static create(isPure, isDebug) {
    return isPure ? new Logger(isDebug) : Logger.consoleLogger(isDebug);
  }
  format(args, style = (x) => x) {
    return args.map((msg) => formatWithOptions({ colors: true }, msg)).map((msg) => style(msg)).join("\n");
  }
  log(type, message) {
    const logObject = { type, message };
    this.logs.push(logObject);
    this.emit("log", logObject);
    this.emit(type, message);
  }
  debug(...data) {
    if (this.isDebug) {
      const message = this.format(data, styles.debug);
      this.log("debug", message);
    }
  }
  info(...data) {
    const message = this.format(data);
    this.log("info", message);
  }
  warn(...data) {
    const message = this.format(data, styles.warning);
    this.log("warning", message);
  }
  error(...data) {
    const message = this.format(data, styles.error);
    this.log("error", message);
  }
  consume() {
    const logs = this.logs;
    this.logs = [];
    return logs.map((l) => l.message).join("\n");
  }
}

class Plugin {
  constructor() {
  }
  _initialize(context) {
    var _a;
    this.context = context;
    (_a = this.onContext) === null || _a === void 0 ? void 0 : _a.call(this);
    this.onCreateStackTags && context.addListener("create-stack-tags", this.onCreateStackTags.bind(this));
    this.onCreateStages && context.addListener("create-stages", this.onCreateStages.bind(this));
    this.onStageStart && context.addListener("stage-start", this.onStageStart.bind(this));
    this.onStageEnd && context.addListener("stage-end", this.onStageEnd.bind(this));
    this.onPipelineStart && context.addListener("pipeline-start", this.onPipelineStart.bind(this));
    this.onPipelineEnd && context.addListener("pipeline-end", this.onPipelineEnd.bind(this));
  }
}

const { diff, gt, lt } = semver;
const AGRIPPA_NPM_ENDPOINT = "https://registry.npmjs.org/agrippa/latest";
class UpdatesPlugin extends Plugin {
  constructor() {
    super(...arguments);
    this.currentVersion = void 0;
    this.requestPromise = null;
    this.failed = false;
  }
  pingRegistry() {
    return __awaiter(this, void 0, void 0, function* () {
      const { logger } = this.context;
      logger.debug("UpdatesPlugin: pinging the npm registry");
      const sendTime = Date.now();
      try {
        const res = yield axios.get(AGRIPPA_NPM_ENDPOINT, {
          timeout: 5e3
        });
        const endTime = Date.now();
        logger.debug(`UpdatesPlugin: request resolved with status ${res.status}, took ${endTime - sendTime}ms`);
        const latestVersion = res.data.version;
        return latestVersion;
      } catch (e) {
        logger.debug(`UpdatesPlugin - ${e.code === "ECONNABORTED" ? "pinging the NPM registry timed out." : "pinging the NPM registry failed."}`);
        this.failed = true;
        logger.debug(e);
        return;
      }
    });
  }
  onPipelineStart() {
    this.currentVersion = this.context.version;
    this.requestPromise = this.pingRegistry();
  }
  onPipelineEnd() {
    return __awaiter(this, void 0, void 0, function* () {
      const { logger } = this.context;
      const currentVersion = this.currentVersion;
      const latestVersion = yield this.requestPromise;
      if (this.failed) {
        return;
      }
      logger.debug(`Current version: ${italic(currentVersion)}, Latest version: ${italic(latestVersion)}`);
      if (!currentVersion || !latestVersion) {
        logger.warn("Error in UpdatesPlugin: currentVersion or latestVersion are not set.");
        return;
      }
      if (gt(latestVersion, currentVersion)) {
        const df = diff(latestVersion, currentVersion);
        logger.info(bold(`New ${df} version available: ${latestVersion}!`), bold(`please update now by typing ${styles.command("npm i -g agrippa")} into the terminal`));
      } else if (lt(latestVersion, currentVersion)) {
        logger.debug("Current version is greater than the latest stable release");
      }
    });
  }
}

const TELEMETRY_ENDPOINT = "https://agrippa-report-worker.nitzanhen.workers.dev/";
class TelemetryPlugin extends Plugin {
  onPipelineEnd() {
    return __awaiter(this, void 0, void 0, function* () {
      const { options, logger, version } = this.context;
      const runData = Object.assign(Object.assign({}, pick(options, "framework", "typescript", "styling")), { version });
      const sendTime = Date.now();
      try {
        logger.debug("TelemetryPlugin: sending report...");
        yield axios.post(TELEMETRY_ENDPOINT, runData, {
          timeout: options.debug ? 0 : 1
        }).catch((e) => {
          if (!options.debug && e.code === "ECONNABORTED") {
            return;
          }
          throw e;
        });
        const endTime = Date.now();
        logger.debug(`TelemetryPlugin: received response in ${endTime - sendTime}ms.`);
      } catch (e) {
        const endTime = Date.now();
        logger.debug(`TelemetryPlugin: request failed after ${endTime - sendTime}ms. Error:`);
        logger.debug(e);
      }
    });
  }
}

class Stage {
  constructor() {
    this.silent = false;
  }
}

function isSubDirectory(parent, dir) {
  if (parent === dir) {
    return true;
  }
  const relativePath = path.relative(parent, dir);
  return !!relativePath && !relativePath.startsWith("..") && !path.isAbsolute(relativePath);
}

class StageResult {
  constructor(status, summary) {
    this.status = status;
    this.summary = summary;
  }
}
const stageStatusBullets = {
  success: "\u2713",
  warning: "\u2713",
  error: "\u2717",
  NA: "\u2022"
};
var StageStatus;
(function(StageStatus2) {
  StageStatus2["SUCCESS"] = "success";
  StageStatus2["WARNING"] = "warning";
  StageStatus2["ERROR"] = "error";
  StageStatus2["NA"] = "NA";
})(StageStatus || (StageStatus = {}));
const summaryLine = ({ status, summary }) => styles[status].bold(`${stageStatusBullets[status]} ${summary}`);

class CreateDirStage extends Stage {
  constructor({ dir, recursive = true, varKey }) {
    super();
    this.dir = dir;
    this.recursive = recursive;
    this.varKey = varKey;
  }
  updateContext(context) {
    context.addDir(this.dir);
    if (this.varKey) {
      context.addVariable(this.varKey, this.dir.path);
    }
  }
  execute(context, logger) {
    return __awaiter(this, void 0, void 0, function* () {
      const { options } = context;
      const { pure, baseDir, allowOutsideBase, overwrite } = options;
      const { path } = this.dir;
      const dirName = basename(path);
      if (pure) {
        this.updateContext(context);
        return new StageResult(StageStatus.NA, "No directory created (pure mode)");
      }
      if (baseDir && !isSubDirectory(baseDir, path) && !allowOutsideBase) {
        logger.error(joinLines(`The resolved path for the directory ${italic(dirName)} falls outside the base directory.`, `Base directory: ${italic(baseDir)}`, `Resolved directory: ${italic(path)}`, "To allow this behaviour, pass the '--allow-outside-base' flag or set 'allowOutsideBase: true' in agrippa.config.mjs"));
        return new StageResult(StageStatus.ERROR, "Directory path outside baseDir");
      }
      logger.info(`path: ${styles.path(path)}`);
      if (existsSync(path) && !overwrite) {
        logger.info(`To allow overwriting, pass ${bold("--overwrite")} to the command.`);
        return new StageResult(StageStatus.ERROR, `Directory ${italic(dirName)} already exists.`);
      }
      try {
        yield mkdir(path, { recursive: this.recursive });
        this.updateContext(context);
        return new StageResult(StageStatus.SUCCESS, `Directory ${italic(dirName)} created successfully.`);
      } catch (e) {
        logger.error(e);
        return new StageResult(StageStatus.ERROR, `Creation of directory ${dirName} failed.`);
      }
    });
  }
}

class CreateFileStage extends Stage {
  constructor({ file, varKey }) {
    super();
    this.file = file;
    this.varKey = varKey;
  }
  updateContext(context) {
    context.addFile(this.file);
    if (this.varKey) {
      context.addVariable(this.varKey, this.file.path);
    }
  }
  execute(context, logger) {
    return __awaiter(this, void 0, void 0, function* () {
      const { options } = context;
      const { pure, baseDir, allowOutsideBase, overwrite } = options;
      const { data, path } = this.file;
      if (pure) {
        this.updateContext(context);
        return new StageResult(StageStatus.NA, "No file created (pure mode)");
      }
      const filename = basename(path);
      if (baseDir && !isSubDirectory(baseDir, path) && !allowOutsideBase) {
        logger.error(joinLines(`The resolved path for the directory ${italic(filename)} falls outside the base directory.`, `Base directory: ${italic(baseDir)}`, `Resolved directory: ${italic(path)}`, "To allow this behaviour, pass the '--allow-outside-base' flag or set 'allowOutsideBase: true' in agrippa.config.mjs"));
        return new StageResult(StageStatus.ERROR, "Directory path outside baseDir");
      }
      logger.info(`path: ${styles.path(path)}`);
      if (existsSync(path)) {
        if (!overwrite) {
          logger.info(`To allow overwriting, pass ${bold("--overwrite")} to the command.`);
          return new StageResult(StageStatus.ERROR, `File ${italic(filename)} already exists.`);
        }
        logger.info("File exists, and was overwritten.");
      }
      try {
        yield writeFile(path, data);
        this.updateContext(context);
        return new StageResult(StageStatus.SUCCESS, `File ${italic(filename)} created successfully.`);
      } catch (e) {
        logger.error(e);
        return new StageResult(StageStatus.ERROR, `Creation of file ${filename} failed.`);
      }
    });
  }
}

class AgrippaFile {
  constructor(path, data) {
    this.path = path;
    this.data = data;
  }
  get directory() {
    return dirname(this.path);
  }
  get extension() {
    return extname(this.path);
  }
  get fileName() {
    return basename(this.path, this.extension);
  }
  toJSON() {
    return JSON.stringify({
      path: this.path,
      data: this.data,
      directory: this.directory,
      extension: this.extension,
      fileName: this.fileName
    });
  }
}

class AgrippaDir {
  constructor(path) {
    this.path = path;
  }
}

class CreateDirPlugin extends Plugin {
  constructor({ dir, recursive, varKey }) {
    super();
    this.dir = dir;
    this.recursive = recursive;
    this.varKey = varKey;
  }
  onCreateStages() {
    this.context.addStage(new CreateDirStage({
      dir: this.dir,
      recursive: this.recursive,
      varKey: this.varKey
    }));
  }
}

class CreateFilePlugin extends Plugin {
  constructor({ file, varKey }) {
    super();
    this.file = file;
    this.varKey = varKey;
  }
  onCreateStages() {
    this.context.addStage(new CreateFileStage({
      file: this.file,
      varKey: this.varKey
    }));
  }
}

const exec = promisify(exec$1);
class RunCommandStage extends Stage {
  constructor({ rawCommand }) {
    super();
    this.rawCommand = rawCommand;
  }
  execute(context, logger) {
    return __awaiter(this, void 0, void 0, function* () {
      logger.debug("runCommand: initiated");
      logger.debug(`Raw command (before substituting variables): ${this.rawCommand}`);
      const { variables } = context;
      logger.debug("Context variables:", variables);
      const command = reduce.object(variables, (cmd, value, key) => cmd.replace(`<${key}>`, value), this.rawCommand);
      logger.debug(`Command (after substituting variables): ${command}`);
      try {
        const { stdout, stderr } = yield exec(command);
        if (stderr) {
          throw new Error(stderr);
        }
        logger.info(stdout ? `output: ${stdout}` : "No output received from command.");
        return new StageResult(StageStatus.SUCCESS, "Post command successfully executed");
      } catch (e) {
        logger.error(e);
        return new StageResult(StageStatus.ERROR, "Post command failed");
      }
    });
  }
}

class PostCommandPlugin extends Plugin {
  constructor(command) {
    super();
    this.command = command;
  }
  onCreateStages() {
    this.context.addStage(new RunCommandStage({ rawCommand: this.command }));
  }
}

class StackTagPlugin extends Plugin {
  constructor(tags) {
    super();
    this.tags = tags;
  }
  onCreateStackTags() {
    for (const tag of this.tags) {
      this.context.addStackTag(tag);
    }
  }
}

class Blocks {
  constructor(initialBlocks = []) {
    this.initialBlocks = initialBlocks;
    const keyBlockPairs = initialBlocks.map((b) => tuple(b.key, b));
    this.blocks = new Map(keyBlockPairs);
  }
  get(key) {
    return this.blocks.get(key);
  }
  add({ key, precedence, data, separator = "\n\n" }) {
    this.blocks.set(key, { key, precedence, data, separator });
  }
  delete(key) {
    return this.blocks.delete(key);
  }
  join() {
    if (this.blocks.size === 0) {
      return "";
    }
    const blocksSorted = [...this.blocks.values()].sort((b1, b2) => b1.precedence - b2.precedence);
    const head = blocksSorted.slice(0, -1);
    const last = blocksSorted[blocksSorted.length - 1];
    return [
      ...head.map(({ data, separator }) => data + separator),
      last.data
    ].join("");
  }
}

var Import;
(function(Import2) {
  function stringify(i) {
    const { module, namedImports, defaultImport } = i;
    const namedString = (namedImports === null || namedImports === void 0 ? void 0 : namedImports.length) ? `{ ${namedImports === null || namedImports === void 0 ? void 0 : namedImports.join(", ")} }` : null;
    return `import ${defaultImport !== null && defaultImport !== void 0 ? defaultImport : ""}${cstr(!!defaultImport && !!namedString, ", ")}${namedString !== null && namedString !== void 0 ? namedString : ""}${cstr(!!defaultImport || !!namedString, " from ")}'${module}';`;
  }
  Import2.stringify = stringify;
  function merge(i1, i2) {
    var _a, _b;
    if (i1.module !== i2.module) {
      throw new RangeError("Illogical merge: both imports must refer to the same module");
    }
    const module = i1.module;
    const default1 = i1.defaultImport;
    const default2 = i2.defaultImport;
    const named1 = (_a = i1.namedImports) !== null && _a !== void 0 ? _a : [];
    const named2 = (_b = i2.namedImports) !== null && _b !== void 0 ? _b : [];
    if (default1 && default2 && default1 !== default2) {
      throw new RangeError("Illogical merge: cannot merge two different default imports.");
    }
    const defaultImport = default1 !== null && default1 !== void 0 ? default1 : default2;
    const namedImports = [...named1, ...named2];
    return {
      module,
      defaultImport,
      namedImports: namedImports.length > 0 ? namedImports : void 0
    };
  }
  Import2.merge = merge;
})(Import || (Import = {}));

class Imports {
  constructor() {
    this.imports = /* @__PURE__ */ new Map();
  }
  get(module) {
    return this.imports.get(module);
  }
  delete(module) {
    return this.imports.delete(module);
  }
  add(newImport) {
    const module = newImport.module;
    const oldImport = this.imports.get(module);
    const i = oldImport ? Import.merge(oldImport, newImport) : newImport;
    this.imports.set(module, i);
  }
  get size() {
    return this.imports.size;
  }
  getBlock() {
    const data = [...this.imports.values()].map(Import.stringify).join("\n") + "\n";
    return {
      key: Imports.BLOCK_KEY,
      precedence: Imports.BLOCK_PRECEDENCE,
      data,
      separator: "\n"
    };
  }
}
Imports.BLOCK_KEY = "imports";
Imports.BLOCK_PRECEDENCE = -Number.EPSILON;

var Comment;
(function(Comment2) {
  function stringify(c) {
    switch (c.type) {
      case "single":
        return c.content.split("\n").map((ln) => `// ${ln}`).join("");
      case "block":
        return pipe(c.content)((data) => data.split("\n").map((ln) => " * " + ln).join("\n"))((body) => `/*
${body}
 */`).go();
      case "jsdoc":
        return pipe(c.content)((data) => data.split("\n").map((ln) => " * " + ln).join("\n"))((body) => `/**
${body}
 */`).go();
    }
  }
  Comment2.stringify = stringify;
})(Comment || (Comment = {}));

class CodeComposer {
  constructor(options) {
    this.plugins = [];
    this.options = options;
  }
  addPlugin(plugin) {
    const keyIndex = plugin.id ? this.plugins.findIndex((p) => p.id === plugin.id) : -1;
    if (keyIndex === -1) {
      this.plugins.push(plugin);
    } else {
      this.plugins.splice(keyIndex, 1, plugin);
    }
  }
  compose() {
    const blocks = new Blocks();
    const imports = new Imports();
    for (const plugin of this.plugins) {
      plugin.onCompose(blocks, imports, this.options);
    }
    if (imports.size > 0) {
      blocks.add(imports.getBlock());
    }
    return blocks.join();
  }
}

const declareConst = (name, value, exported = false, type = "") => `${cstr(exported, "export ")}const ${name}${cstr(!!type, `: ${type}`)} = ${value};`;
const declareInterface = (name, exported = false) => `${cstr(exported, "export ")}interface ${name} {}`;
const declareType = (name, exported = false) => `${cstr(exported, "export ")}type ${name} = {};`;
const declareFunction = (name, params = "", body = "", exported = false) => `${cstr(exported, "export ")}function ${name}(${params}) {${body ? `
${indent(body)}
` : " "}}`;
const createArrowFunction = (params = "", body = "") => `(${params}) => {${cstr(!!body, "\n" + indent(body) + "\n")}}`;
const createDefaultExport = (name) => `export default ${name};`;
const createAssignment = (target, key, value) => `${target}.${key} = ${value};`;

const DECLARATION_BLOCK_KEY = "declaration";
const DECLARATION_BLOCK_PRECEDENCE = 10;
const TS_PROPS_BLOCK_KEY = "ts-prop-declaration";
const TS_PROPS_BLOCK_PRECEDENCE = 5;
const DEFAULT_EXPORT_BLOCK_KEY = "default-export";
const DEFAULT_EXPORT_BLOCK_PRECEDENCE = 20;
class JSXPlugin {
  constructor(options) {
    this.options = options;
    const { typescript, typescriptOptions } = options;
    if (typescript && !typescriptOptions) {
      throw TypeError("JSXPlugin requires Options.typescriptOptions to be set whenever Options.typescript is set");
    }
    this.typescriptOptions = typescriptOptions;
  }
  get propInterfaceName() {
    return this.options.name + "Props";
  }
  getComponentParams() {
    return this.options.typescript ? `props: ${this.propInterfaceName}` : "props";
  }
  getComponentBody() {
    return joinLines("", "return (", indent(`<${this.rootTag}></${this.rootTag}>`), ");");
  }
  getTSPropsDeclaration() {
    const { typescript } = this.options;
    if (!typescript) {
      throw new Error("getTSPropsDeclaration() called but typescript is false. This shouldn't be possible.");
    }
    const { propDeclaration } = this.typescriptOptions;
    switch (propDeclaration) {
      case "type":
        return declareType(this.propInterfaceName, true);
      case "interface":
        return declareInterface(this.propInterfaceName, true);
      default:
        return null;
    }
  }
  getComponentConstDeclaration() {
    const { name, componentOptions: { exportType } } = this.options;
    return declareConst(name, createArrowFunction(this.getComponentParams(), this.getComponentBody()), exportType === "named");
  }
  getComponentFunctionDeclaration() {
    const { name, componentOptions: { exportType } } = this.options;
    return declareFunction(name, this.getComponentParams(), this.getComponentBody(), exportType === "named");
  }
  getComponentDeclaration() {
    const { componentOptions: { declaration } } = this.options;
    return declaration === "const" ? this.getComponentConstDeclaration() : this.getComponentFunctionDeclaration();
  }
  onCompose(blocks, imports, options) {
    const { typescript, componentOptions: { exportType }, name } = this.options;
    this.declareImports(imports);
    if (typescript) {
      const propsDeclaration = this.getTSPropsDeclaration();
      if (propsDeclaration) {
        blocks.add({
          key: TS_PROPS_BLOCK_KEY,
          precedence: TS_PROPS_BLOCK_PRECEDENCE,
          data: propsDeclaration
        });
      }
    }
    blocks.add({
      key: DECLARATION_BLOCK_KEY,
      precedence: DECLARATION_BLOCK_PRECEDENCE,
      data: this.getComponentDeclaration()
    });
    if (exportType === "default") {
      blocks.add({
        key: DEFAULT_EXPORT_BLOCK_KEY,
        precedence: DEFAULT_EXPORT_BLOCK_PRECEDENCE,
        data: createDefaultExport(name)
      });
    }
  }
}

class ReactPlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "react";
    this.rootTag = "div";
    if (options.styling === Styling.STYLED_COMPONENTS) {
      this.rootTag = "Root";
    }
    const { reactOptions } = options;
    if (!reactOptions) {
      throw TypeError("ReactPlugin requires Options.reactOptions to be set");
    }
    this.reactOptions = reactOptions;
  }
  declareImports(imports) {
    if (this.reactOptions.importReact) {
      imports.add({ module: "react", defaultImport: "React" });
    }
  }
}

const RN_STYLING_BLOCK_KEY = "react-native-styling";
const RN_STYLING_BLOCK_PRECEDENCE = 7;
class ReactNativePlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "react-native";
    this.rootTag = "View";
    const { reactOptions, reactNativeOptions } = options;
    if (!reactOptions || !reactNativeOptions) {
      throw TypeError("ReactPlugin requires Options.reactOptions and Options.reactNativeOptions to be set");
    }
    this.reactOptions = reactOptions;
    this.reactNativeOptions = reactNativeOptions;
  }
  declareImports(imports) {
    if (this.reactOptions.importReact) {
      imports.add({ module: "react", defaultImport: "React" });
    }
    imports.add({ module: "react-native", namedImports: ["View"] });
    if (this.options.styling === Styling.REACT_NATIVE) {
      imports.add({ module: "react-native", namedImports: ["StyleSheet"] });
    }
  }
  onCompose(blocks, imports, options) {
    super.onCompose(blocks, imports, options);
    if (this.options.styling === Styling.REACT_NATIVE) {
      blocks.add({
        key: RN_STYLING_BLOCK_KEY,
        precedence: RN_STYLING_BLOCK_PRECEDENCE,
        data: declareConst("styles", "StyleSheet.create({})")
      });
    }
  }
}

class SolidPlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "solidjs";
    this.rootTag = "div";
    const solidjsOptions = options.solidjsOptions;
    if (!solidjsOptions) {
      throw TypeError("SolidPlugin requires Options.solidjsOptions to be set");
    }
    this.solidjsOptions = solidjsOptions;
  }
  declareImports() {
  }
}

class PreactPlugin extends JSXPlugin {
  constructor(options) {
    super(options);
    this.options = options;
    this.id = "preact";
    this.rootTag = "div";
    const preactOptions = options.preactOptions;
    if (!preactOptions) {
      throw TypeError("PreactPlugin requires Options.preactOptions to be set");
    }
    this.preactOptions = preactOptions;
  }
  declareImports() {
  }
}

class ImportPlugin {
  constructor(i) {
    this.import = i;
  }
  onCompose(blocks, imports, options) {
    imports.add(this.import);
  }
}

class CommentPlugin {
  constructor(comment, key, precedence) {
    this.comment = comment;
    this.key = key;
    this.precedence = precedence;
  }
  onCompose(blocks, imports, options) {
    blocks.add({
      key: this.key,
      precedence: this.precedence,
      data: Comment.stringify(this.comment)
    });
  }
}

const PROP_TYPES_BLOCK_KEY = "prop-types";
const PROP_TYPES_BLOCK_PRECEDENCE = 15;
class PropTypesPlugin {
  constructor() {
    this.id = "prop-types";
  }
  getPropTypesDeclaration(name) {
    return createAssignment(name, "propTypes", "{}");
  }
  onCompose(blocks, imports, options) {
    const { name } = options;
    imports.add({
      module: "prop-types",
      defaultImport: "PropTypes"
    });
    blocks.add({
      key: PROP_TYPES_BLOCK_KEY,
      precedence: PROP_TYPES_BLOCK_PRECEDENCE,
      data: this.getPropTypesDeclaration(name)
    });
  }
}

const TS_CHECK_BLOCK_KEY = "ts-check";
const TS_CHECK_BLOCK_PRECEDENCE = -1;
const DECLARATION_JSDOC_BLOCK_KEY = "declaration-jsdoc";
const DECLARATION_JSDOC_BLOCK_PRECEDENCE = DECLARATION_BLOCK_PRECEDENCE - 1;
const PROPS_JSDOC_BLOCK_KEY = "props-jsdoc";
const PROPS_JSDOC_BLOCK_PRECEDENCE = 5;
class JSDocPlugin {
  constructor(options, { getCommentContent, generateTypes = false, includeTsCheck = generateTypes } = {}) {
    this.id = "jsdoc";
    this.options = options;
    this.getCommentContent = getCommentContent;
    this.generateTypes = generateTypes;
    this.includeTsCheck = includeTsCheck;
  }
  get propInterfaceName() {
    return this.options.name + "Props";
  }
  onCompose(blocks, _) {
    var _a, _b;
    if (this.includeTsCheck) {
      blocks.add({
        key: TS_CHECK_BLOCK_KEY,
        precedence: TS_CHECK_BLOCK_PRECEDENCE,
        data: Comment.stringify({ type: "single", content: "@ts-check" }),
        separator: "\n"
      });
    }
    if (this.generateTypes) {
      blocks.add({
        key: PROPS_JSDOC_BLOCK_KEY,
        precedence: PROPS_JSDOC_BLOCK_PRECEDENCE,
        data: Comment.stringify({ type: "jsdoc", content: `@typedef {Object} ${this.propInterfaceName}` })
      });
    }
    const commentContent = (_b = (_a = this.getCommentContent) === null || _a === void 0 ? void 0 : _a.call(this, this.options)) !== null && _b !== void 0 ? _b : "";
    const commentString = commentContent + cstr(this.generateTypes, `
@param {${this.propInterfaceName}} props`);
    blocks.add({
      key: DECLARATION_JSDOC_BLOCK_KEY,
      precedence: DECLARATION_JSDOC_BLOCK_PRECEDENCE,
      data: Comment.stringify({ type: "jsdoc", content: commentString }),
      separator: "\n"
    });
  }
}

const frameworkTags = {
  [Framework.REACT]: "React",
  [Framework.REACT_NATIVE]: "React Native",
  [Framework.SOLIDJS]: "SolidJS",
  [Framework.PREACT]: "Preact"
};
const stylingTags = {
  [Styling.CSS]: "CSS",
  [Styling.SCSS]: "SCSS",
  [Styling.JSS]: "JSS",
  [Styling.STYLED_COMPONENTS]: "styled-components"
};
function getStackTags(options) {
  var _a;
  const { framework, styling, typescript } = options;
  const fwTag = (_a = frameworkTags[framework]) !== null && _a !== void 0 ? _a : capitalize(framework);
  const typescriptTag = typescript ? "TypeScript" : void 0;
  const stylingTag = styling && stylingTags[styling];
  const stackTags = [
    fwTag,
    typescriptTag,
    stylingTag
  ].filter((tag) => !!tag);
  return stackTags;
}

const getDirPath = ({ baseDir, destination, name }) => resolve(baseDir !== null && baseDir !== void 0 ? baseDir : process.cwd(), destination, name);
const getFrameworkPlugin = (options, logger) => {
  switch (options.framework) {
    case Framework.REACT:
      return new ReactPlugin(options);
    case Framework.REACT_NATIVE:
      return new ReactNativePlugin(options);
    case Framework.SOLIDJS:
      return new SolidPlugin(options);
    case Framework.PREACT:
      return new PreactPlugin(options);
    default:
      {
        logger.warn("", "No framework flag was received, and Agrippa was unable to detect the framework automatically. Please check your configuration.");
        return null;
      }
  }
};
function defaultStyleFileImport(options, logger, styleFileName) {
  const { styling, name, styleFileOptions } = options;
  if (styling === Styling.CSS || styling === Styling.SCSS) {
    return {
      module: `./${styleFileName}`,
      defaultImport: (styleFileOptions === null || styleFileOptions === void 0 ? void 0 : styleFileOptions.module) ? "classes" : void 0
    };
  }
  if (styling === Styling.STYLED_COMPONENTS) {
    return {
      module: `./${name}.styles`,
      namedImports: ["Root"]
    };
  }
  logger.debug(`defaultStyleFileImport called for unknown styling option, ${styling}`);
  return void 0;
}
function defaultComponentFile(options, logger, additionalImports) {
  const { name, typescript } = options;
  const dirPath = getDirPath(options);
  const componentFileExtension = typescript ? "tsx" : "jsx";
  const componentFileName = `${name}.${componentFileExtension}`;
  const componentFilePath = join(dirPath, componentFileName);
  const composer = new CodeComposer(options);
  const frameworkPlugin = getFrameworkPlugin(options, logger);
  if (frameworkPlugin) {
    composer.addPlugin(frameworkPlugin);
  }
  additionalImports === null || additionalImports === void 0 ? void 0 : additionalImports.map((i) => {
    composer.addPlugin(new ImportPlugin(i));
  });
  return new AgrippaFile(componentFilePath, composer.compose());
}
function defaultIndexFile(options) {
  const { name, componentOptions: { exportType }, typescript } = options;
  const dirPath = getDirPath(options);
  const fileName = `index.${typescript ? "ts" : "js"}`;
  const path = join(dirPath, fileName);
  const code = joinLines(`export * from './${name}';`, exportType === "default" && `export { default } from './${name}';`);
  return new AgrippaFile(path, code);
}
function defaultPlugins(options, logger) {
  const { name, typescript, styling, styleFileOptions, createStylesFile } = options;
  const dirPath = getDirPath(options);
  const stylesFileName = styling === "styled-components" ? `${name}.styles.${typescript ? "ts" : "js"}` : `${kebabCase(name)}${(styleFileOptions === null || styleFileOptions === void 0 ? void 0 : styleFileOptions.module) ? ".module" : ""}.${styling}`;
  const styleFileContent = styling === "styled-components" ? joinLines(Import.stringify({ module: "styled-components", defaultImport: "styled" }), declareConst("Root", "styled.div``", true)) : "";
  const stylesFilePath = join(dirPath, stylesFileName);
  const styleFileImport = createStylesFile ? defaultStyleFileImport(options, logger, stylesFileName) : void 0;
  return [
    new StackTagPlugin(getStackTags(options)),
    new CreateDirPlugin({
      dir: new AgrippaDir(dirPath),
      varKey: "dirPath"
    }),
    new CreateFilePlugin({
      file: defaultComponentFile(options, logger, styleFileImport && [styleFileImport]),
      varKey: "componentPath"
    }),
    createStylesFile && new CreateFilePlugin({
      file: new AgrippaFile(stylesFilePath, styleFileContent),
      varKey: "stylesPath"
    }),
    new CreateFilePlugin({
      file: defaultIndexFile(options),
      varKey: "indexPath"
    })
  ].filter((p) => !!p);
}

class AsyncEventEmitter {
  constructor() {
    this.handlerMap = /* @__PURE__ */ Object.create(null);
  }
  addListener(event, handler) {
    if (!this.handlerMap[event]) {
      this.handlerMap[event] = /* @__PURE__ */ new Set();
    }
    this.handlerMap[event].add(handler);
  }
  on(event, handler) {
    return this.addListener(event, handler);
  }
  removeListener(event, handler) {
    var _a;
    (_a = this.handlerMap[event]) === null || _a === void 0 ? void 0 : _a.delete(handler);
  }
  off(event, handler) {
    return this.removeListener(event, handler);
  }
  emit(event, ...args) {
    return __awaiter(this, void 0, void 0, function* () {
      const handlers = this.handlerMap[event];
      if (!handlers) {
        return;
      }
      for (const handler of handlers) {
        yield handler(...args);
      }
    });
  }
}

const parseJson = JSON5.parse;
const thisPath = typeof import.meta !== "undefined" ? dirname(fileURLToPath(import.meta.url)) : __dirname;
const pkgJsonPath = findUp.sync("package.json", { cwd: thisPath });
const pkgJson = parseJson(readFileSync(pkgJsonPath, "utf-8"));

class Context extends AsyncEventEmitter {
  constructor({ options, plugins, stages = [], createdFiles = [], createdDirs = [], variables = {}, logger, stackTags = [] }) {
    super();
    this.version = pkgJson.version;
    this.logger = logger !== null && logger !== void 0 ? logger : Logger.create(options.pure, options.debug);
    this.stages = stages;
    this.stagesInitialized = false;
    this.options = options;
    this.plugins = plugins !== null && plugins !== void 0 ? plugins : defaultPlugins(options, this.logger);
    this.createdFiles = createdFiles;
    this.createdDirs = createdDirs;
    this.variables = variables;
    this.stackTags = stackTags;
    this.stackTagsInitialized = false;
    for (const plugin of this.plugins) {
      plugin._initialize(this);
    }
  }
  get pure() {
    return this.options.pure;
  }
  get debug() {
    return this.options.debug;
  }
  addStage(stage) {
    this.stages.push(stage);
  }
  getStages() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.stagesInitialized) {
        this.logger.debug("Initializing stages...");
        yield this.emit("create-stages");
        this.stagesInitialized = true;
        this.logger.debug("Initialized stages:", this.stages);
      }
      return this.stages;
    });
  }
  addStackTag(tag) {
    this.stackTags.push(tag);
  }
  getStackTags() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.stackTagsInitialized) {
        this.logger.debug("Initializing stack tags...");
        yield this.emit("create-stack-tags");
        this.stackTagsInitialized = true;
        this.logger.debug("Initialized stack tags: ", this.stackTags);
      }
      return this.stackTags;
    });
  }
  addPlugin(plugin) {
    this.plugins.push(plugin);
    plugin._initialize(this);
  }
  addFile(file) {
    this.createdFiles.push(file);
  }
  addDir(dir) {
    this.createdDirs.push(dir);
  }
  addVariable(key, value) {
    this.variables[key] = value;
  }
  execute() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getStages();
      yield this.getStackTags();
      const logger = this.logger;
      logger.debug("Executing pipeline: running stages", "");
      yield this.emit("pipeline-start");
      for (const stage of this.stages) {
        yield this.emit("stage-start", stage);
        const stageLogger = new Logger();
        const result = yield stage.execute(this, stageLogger);
        const stageLogs = stageLogger.consume();
        if (!stage.silent) {
          logger.info(summaryLine(result));
          logger.info(indent(styles.comment(stageLogs), 2, " ") + "\n");
        } else {
          logger.debug(stageLogs);
        }
        yield this.emit("stage-end", stage);
      }
      yield this.emit("pipeline-end");
      logger.debug("Pipeline execution complete.");
      const output = {
        options: this.options,
        plugins: this.plugins,
        stages: this.stages,
        createdFiles: this.createdFiles,
        createdDirs: this.createdDirs,
        variables: this.variables,
        stackTags: this.stackTags,
        logs: this.logger.consume()
      };
      return output;
    });
  }
}

function run(inputOptions, runOptions = {}) {
  var _a, _b, _c, _d, _e, _f, _g;
  return __awaiter(this, void 0, void 0, function* () {
    const pure = !!inputOptions.pure;
    const debug = !!inputOptions.debug;
    const logger = (_a = runOptions.logger) !== null && _a !== void 0 ? _a : Logger.create(pure, debug);
    logger.debug(runOptions.logger ? "Using logger passed in runOptions" : `Logger initialized with params pure=${pure}, debug=${debug}`);
    logger.debug(((_b = runOptions.envFiles) === null || _b === void 0 ? void 0 : _b.agrippaConfig) ? "Agrippa config passed through runOptions" : "Searching for agrippa.config.mjs...");
    const [config, configPath] = yield loadFileQuery(((_c = runOptions.envFiles) === null || _c === void 0 ? void 0 : _c.agrippaConfig) ? { path: (_d = runOptions.envFiles) === null || _d === void 0 ? void 0 : _d.agrippaConfig } : { search: "agrippa.config.mjs" });
    logger.debug("Resolved Agrippa config: ", config);
    const envFileQueries = Object.assign({}, config === null || config === void 0 ? void 0 : config.files, runOptions === null || runOptions === void 0 ? void 0 : runOptions.envFiles);
    const envFiles = Object.assign({ config }, !pure && (yield loadFiles(envFileQueries, dirname(configPath !== null && configPath !== void 0 ? configPath : ""))));
    logger.debug("Resolved envFiles: ", envFiles);
    inputOptions = assignDefaults((_e = config === null || config === void 0 ? void 0 : config.options) !== null && _e !== void 0 ? _e : {}, inputOptions);
    const options = createOptions(inputOptions, envFiles);
    logger.debug("Resolved options: ", options);
    const context = new Context({
      options,
      variables: {
        "ComponentName": options.name,
        "component-name": kebabCase(options.name)
      },
      logger
    });
    (_f = runOptions.plugins) === null || _f === void 0 ? void 0 : _f.forEach((p) => context.addPlugin(p));
    (_g = config === null || config === void 0 ? void 0 : config.plugins) === null || _g === void 0 ? void 0 : _g.forEach((p) => context.addPlugin(p));
    if (options.lookForUpdates) {
      context.addPlugin(new UpdatesPlugin());
    } else {
      logger.debug("`options.lookForUpdates` is `false`, not pinging the npm registry");
    }
    if (options.reportTelemetry) {
      context.addPlugin(new TelemetryPlugin());
    } else {
      logger.debug("`options.reportTelemetry` is `false`, not sending usage statistics");
    }
    const stackTags = yield context.getStackTags();
    logger.info("", `Agrippa v${context.version}`, "", `Generating ${styles.componentName(options.name)}
`, `Stack: ${stackTags.map((t) => styles.tag(t)).join(", ")}`, "");
    const output = yield context.execute();
    logger.info("Generation successful. Cheers!");
    return output;
  });
}

export { AgrippaDir, AgrippaFile, Blocks, CodeComposer, Comment, CommentPlugin, Context, CreateDirPlugin, CreateDirStage, CreateFilePlugin, CreateFileStage, DECLARATION_JSDOC_BLOCK_KEY, DECLARATION_JSDOC_BLOCK_PRECEDENCE, FileType, Framework, Import, ImportPlugin, Imports, JSDocPlugin, Logger, PROPS_JSDOC_BLOCK_KEY, PROPS_JSDOC_BLOCK_PRECEDENCE, Plugin, PostCommandPlugin, PreactPlugin, PropTypesPlugin, RN_STYLING_BLOCK_KEY, RN_STYLING_BLOCK_PRECEDENCE, ReactNativePlugin, ReactPlugin, SolidPlugin, StackTagPlugin, Stage, Styling, TS_CHECK_BLOCK_KEY, TS_CHECK_BLOCK_PRECEDENCE, TelemetryPlugin, UpdatesPlugin, bold, capitalize, createOptions, cstr, defaultComponentFile, defaultFramework, defaultIndexFile, defaultPlugins, defaultStyleFileImport, defineConfig, getFrameworkPlugin, indent, isCamelCase, isKebabCase, isLowerCase, isPascalCase, italic, joinLines, kebabCase, loadFile, loadFileQuery, loadFiles, ostr, pascalCase, run, styles };
