const n=n=>Object.keys(n),t=n=>Object.values(n),r=n=>Object.entries(n),e=n=>Object.fromEntries(n),o=t=>0===n(t).length,c=(...n)=>n;function u(...n){if(1===n.length&&"function"==typeof n[0]){const t=n[0];return n=>u(n,t)}const[t,r]=n;return t.filter(r)}function f(...n){if(n.length<=2&&"function"==typeof n[0]){const[t,r={}]=n;return n=>f(n,t,r)}const[t,r,e={}]=n;return t.reduce(((n,t,e)=>{const o=r(t,e);return{...n,[o]:n[o]?[...n[o],t]:[t]}}),e)}function i(n,t=(n=>n)){return[...new Array(n).keys()].map(t)}function s(...n){if(1===n.length&&"function"==typeof n[0]){const t=n[0];return n=>s(n,t)}const[t,r]=n;return t.map(r)}function a(...n){if("object"!=typeof n[0]){const t=n;return n=>a(n,...t)}const[t,...r]=n,e=new Set(r);return u.object(t,((n,t)=>!e.has(t)))}function p(...n){if("object"!=typeof n[0]){const t=n;return n=>p(n,...t)}const[t,...r]=n;return e(r.map((n=>c(n,t[n]))))}function y(...n){if(n.length<=2&&"function"==typeof n[0]){const[t,r]=n;return n=>y(n,t,r)}const[t,r,e]=n;return t.reduce(((n,t,e)=>r(n,t,e)),e)}u.object=function n(...t){if(1===t.length&&"function"==typeof t[0]){const r=t[0];return t=>n(t,r)}const[o,c]=t;return e(r(o).filter((([n,t])=>c(t,n))))},s.object=function n(...t){if(1===t.length&&"function"==typeof t[0]){const r=t[0];return t=>n(t,r)}const[o,u]=t;return e(r(o).map((([n,t])=>c(n,u(t,n)))))},y.object=function n(...t){if(t.length<=2&&"function"==typeof t[0]){const[r,e]=t;return t=>n(t,r,e)}const[e,o,c]=t;return r(e).reduce(((n,[t,r])=>o(n,r,t)),c)};const h=(...n)=>i(Math.min(...n.map((n=>n.length))),(t=>c(...n.map((n=>n[t])))));function l(...n){if(1===n.length){const[[t,r]]=n;return n=>l(n,[t,r])}const[t,[r,e]]=n;return t<r?r:t>e?e:t}function g(...n){if(1===n.length&&"function"==typeof n[0]){const[t]=n;return n=>g(n,t)}const[t,r]=n;return t.map((n=>c(n,r(n)))).reduce(((n,t)=>n[1]<=t[1]?n:t),[void 0,1/0])[0]}function m(...n){if(n.length>1||!Array.isArray(n[0]))return m(n);const[t]=n;return t.reduce(((n,t)=>Math.min(n,t)),1/0)}function d(...n){if(1===n.length&&"function"==typeof n[0]){const[t]=n;return n=>d(n,t)}const[t,r]=n;return t.map((n=>c(n,r(n)))).reduce(((n,t)=>n[1]>=t[1]?n:t),[void 0,-1/0])[0]}function b(...n){if(n.length>1||!Array.isArray(n[0]))return b(n);const[t]=n;return t.reduce(((n,t)=>Math.max(n,t)),-1/0)}function j(...n){if(1===n.length&&"function"==typeof n[0]){const[t]=n;return n=>j(n,t)}const[t,r]=n;return A(t.map(r))}function A(...n){if(n.length>1||!Array.isArray(n[0]))return A(n);const[t]=n;return t.reduce(((n,t)=>n+t),0)}function k(n){return{...n,ok:!0}}function O(n){return{...n,ok:!1}}function v(n){return{ok:!0,data:n}}function M(n){return{ok:!1,error:n}}const w=n=>{try{return v(n())}catch(n){return M(n)}},x=n=>{const t=t=>x(t(n));return t.go=()=>n,t};export{l as clamp,r as entries,M as err,O as errLike,u as filter,f as groupBy,o as isEmpty,n as keys,i as makeArray,s as map,b as max,d as maxItem,m as min,g as minItem,v as ok,k as okLike,a as omit,p as pick,x as pipe,y as reduce,w as safeTry,A as sum,j as sumItems,e as toObject,c as tuple,t as values,h as zip};
