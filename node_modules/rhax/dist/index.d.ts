declare type ValueOf<T> = T[keyof T];
declare type EntryOf<T> = [keyof T, ValueOf<T>];
declare type Fn<A, B> = (arg: A) => B;
declare type ObjectKey = string | number | symbol;

declare type ArrayPredicate<E> = (el: E, index: number) => boolean;
declare type ObjectPredicate<K extends ObjectKey, V> = (value: V, key: K) => boolean;
declare function filter<E>(arr: E[], predicate: ArrayPredicate<E>): E[];
declare function filter<E>(predicate: ArrayPredicate<E>): (arr: E[]) => E[];
declare namespace filter {
    var object: typeof filterObject;
}
declare function filterObject<O extends object>(obj: O, predicate: ObjectPredicate<keyof O, ValueOf<O>>): O;
declare function filterObject<K extends ObjectKey, V>(predicate: ObjectPredicate<K, V>): <O extends Record<K, V>>(obj: O) => O;

declare type ArrayTagger<E, T extends ObjectKey> = (element: E, index: number) => T;
declare function groupBy<E, T extends ObjectKey>(arr: E[], tagger: ArrayTagger<E, T>, initialGroups?: Record<T, E[]>): Record<T, E[]>;
declare function groupBy<E, T extends ObjectKey>(tagger: ArrayTagger<E, T>, initialGroups?: Record<T, E[]>): (arr: E[]) => Record<T, E[]>;

declare const keys: <O extends object>(obj: O) => (keyof O)[];
declare const values: <O extends object>(obj: O) => ValueOf<O>[];
declare const entries: <O extends object>(obj: O) => EntryOf<O>[];
declare const toObject: <K extends ObjectKey, V>(entries: [K, V][]) => Record<K, V>;
declare const isEmpty: (obj: object) => boolean;
declare const tuple: <A extends any[]>(...args: A) => A;

declare function makeArray(len: number): number[];
declare function makeArray<T>(len: number, factory: (index: number) => T): T[];

declare type ArrayMapper<E, W> = (el: E, index: number) => W;
declare type ObjectMapper<K extends ObjectKey, V, W> = (value: V, key: K) => W;
declare function map<E, W>(arr: E[], mapper: ArrayMapper<E, W>): W[];
declare function map<E, W>(mapper: ArrayMapper<E, W>): (arr: E[]) => W[];
declare namespace map {
    var object: typeof mapObject;
}
declare function mapObject<O extends object, W>(obj: O, mapper: ObjectMapper<keyof O, ValueOf<O>, W>): Record<keyof O, W>;
declare function mapObject<K extends ObjectKey, V, W>(mapper: ObjectMapper<K, V, W>): <O extends Record<K, V>>(obj: O) => Record<keyof O, W>;

declare function omit<O extends object, K extends keyof O>(obj: O, ...keys: K[]): Omit<O, K>;
declare function omit<K extends ObjectKey>(...keys: K[]): <O extends Record<K, any>>(obj: O) => Omit<O, K>;

declare function pick<O extends object, K extends keyof O>(obj: O, ...keys: K[]): Pick<O, K>;
declare function pick<K extends ObjectKey>(...keys: K[]): <O extends Record<K, any>>(obj: O) => Pick<O, K>;

declare type ArrayReducer<E, A> = (acc: A, el: E, index: number) => A;
declare type ObjectReducer<K extends ObjectKey, V, A> = (acc: A, value: V, key: K) => A;
declare function reduce<E, A>(arr: E[], reducer: ArrayReducer<E, A>, initialValue: A): A;
declare function reduce<E, A>(reducer: ArrayReducer<E, A>, initialValue: A): (arr: E[]) => A;
declare namespace reduce {
    var object: typeof reduceObject;
}
declare function reduceObject<O extends Object, A>(obj: O, reducer: ObjectReducer<keyof O, ValueOf<O>, A>, initialValue: A): A;
declare function reduceObject<K extends ObjectKey, V, A>(reducer: ObjectReducer<K, V, A>, initialValue: A): <O extends Record<K, V>>(obj: O) => A;

declare type Zipped<Arrs extends [...any[]]> = Arrs extends [(infer H)[], ...(infer T)] ? [H, ...Zipped<T>] : [];
declare const zip: <Arrs extends any[][]>(...arrs: Arrs) => Zipped<Arrs>[];

declare function clamp(x: number, interval: [min: number, max: number]): number;
declare function clamp(interval: [min: number, max: number]): (x: number) => number;

declare function minItem<T>(items: T[], toNumber: (it: T) => number): T;
declare function minItem<T>(toNumber: (it: T) => number): (items: T[]) => T;
declare function min(...numbers: number[]): number;
declare function min(numbers: number[]): number;

declare function maxItem<T>(items: T[], toNumber: (it: T) => number): T;
declare function maxItem<T>(toNumber: (it: T) => number): (items: T[]) => T;
declare function max(...numbers: number[]): number;
declare function max(numbers: number[]): number;

declare function sumItems<T>(items: T[], toNumber: (it: T) => number): number;
declare function sumItems<T>(toNumber: (it: T) => number): (items: T[]) => number;
declare function sum(...numbers: number[]): number;
declare function sum(numbers: number[]): number;

declare type OkLike<T> = {
    ok: true;
} & T;
declare function okLike<T>(data: T): OkLike<T>;
declare type ErrLike<E> = {
    ok: false;
} & E;
declare function errLike<E>(error: E): ErrLike<E>;
declare type ResultLike<T, E> = OkLike<T> | ErrLike<E>;

declare type Ok<T> = OkLike<{
    data: T;
}>;
declare function ok<T>(data: T): Ok<T>;
declare type Err<E> = ErrLike<{
    error: E;
}>;
declare function err<E>(error: E): Err<E>;
declare type Result<T, E = unknown> = Ok<T> | Err<E>;

declare const safeTry: <T, E = unknown>(op: () => T) => Result<T, E>;

interface Pipe<T> {
    <S>(fn: Fn<T, S>): Pipe<S>;
    go(): T;
}
interface PipeFactory {
    (): Pipe<void>;
    <T>(x: T): Pipe<T>;
}
declare const pipe: PipeFactory;

export { ArrayMapper, ArrayPredicate, ArrayReducer, ArrayTagger, EntryOf, Err, ErrLike, Fn, ObjectKey, ObjectMapper, ObjectPredicate, ObjectReducer, Ok, OkLike, Pipe, PipeFactory, Result, ResultLike, ValueOf, Zipped, clamp, entries, err, errLike, filter, groupBy, isEmpty, keys, makeArray, map, max, maxItem, min, minItem, ok, okLike, omit, pick, pipe, reduce, safeTry, sum, sumItems, toObject, tuple, values, zip };
